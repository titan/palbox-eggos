#+STARTUP: indent
* 通讯协议

** 通讯命令

 | no | cmd            | 说明            |
 |----+----------------+-----------------|
 |  0 | UNKNOWN        | 未知命令        |
 |  1 | ACK            | 响应            |
 |  2 | LOCK-OFF       | 开锁            |
 |  3 | LOCK-ON        | 关锁            |
 |  4 | PLAY           | 播放语音        |
 |  5 | GPIO           | 设置 GPIO       |

#+begin_src c :noweb-ref command-type
  typedef enum EGG_CMD_TYPE {
    EGG_UNKNOWN = 0x00,
    EGG_ACK = 0x01,
    EGG_LOCK_OFF= 0x1B,
    EGG_LOCK_ON = 0x1A,
    EGG_PLAY = 0x1C,
    EGG_GPIO = 0x1D,
  } egg_cmd_type_t;
#+end_src

** 数据结构

*** 数据包

#+begin_src c :noweb-ref packet
  struct egg_packet_t {
    uint8_t egg;
    uint8_t version;
    egg_payload_t payload;
  };
#+end_src


*** 负载

#+begin_src lisp :mkdirp yes :tangle /dev/shm/eggos/protocol.tr
  (struct egg-payload
    (int 0 sn)
    (byte 1 cmd)
    (int 2 timestamp)
    (byte 3 ack-type)
    (byte 4 cabin)
    (int 5 audio)
    (byte 6 gpio)
    )
#+end_src

命令与数据矩阵

| cmd      | cabin | audio | gpio |
|----------+-------+-------+------|
| LOCK OFF | ✓     |       |      |
| LOCK ON  | ✓     |       |      |
| PLAY     |       | ✓     |      |
| GPIO     |       |       | ✓    |

** 数据封包

#+begin_src c :mkdirp yes :noweb yes :tangle /dev/shm/eggos/egg_packet.h
  #ifndef __EGG_PACKET_H
  #define __EGG_PACKET_H
  #include <stdint.h>
  #include "egg_payload.h"
  <<command-type>>
  <<packet>>
  uint32_t egg_packet_calculate_encode_size(struct egg_packet_t * packet);
  uint32_t egg_packet_encode(struct egg_packet_t * packet, uint8_t * buf, uint32_t size);
  uint32_t egg_packet_estimate_decode_size(uint8_t * buf, uint32_t size);
  egg_cmd_type_t egg_packet_decode(uint8_t * buf, uint32_t size, struct egg_packet_t * packet);
  #endif
#+end_src

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/egg_packet.c
  #include "egg_packet.h"
  #include "hash.h"
  #include "base64.h"

  /*
    packet layout:

            +-+-+-+-+-+-+-+-+
    byte 0  |0|0|1|1|0|0|1|1|   magic number 0
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 1  |0|0|1|1|1|1|0|0|   magic number 1
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 1  |1|1|0|0|0|0|1|1|   magic number 2
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 3  |1|1|0|0|1|1|0|0|   magic number 3
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 4  |x|x|x|x|x|x|x|x|   adle32-0 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 5  |x|x|x|x|x|x|x|x|   adle32-1 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 6  |x|x|x|x|x|x|x|x|   adle32-2 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 7  |x|x|x|x|x|x|x|x|   adle32-3 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 8  |0|0|0|0|0|x|x|x|   egg no
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 9  |0|0|0|0|0|0|0|0|   version
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte A  |x|x|x|x|x|x|x|x|   length0 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte B  |x|x|x|x|x|x|x|x|   length1 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte C  |x|x|x|x|x|x|x|x|   begin of data (base64)
            +-+-+-+-+-+-+-+-+
                    .
                    .
                    .
            +-+-+-+-+-+-+-+-+
    byte n  |x|x|x|x|x|x|x|x|   end of data (base64)
            +-+-+-+-+-+-+-+-+

  ,*/

  #define EGG_PACKET_META_SIZE (4 + 4 + 1 + 1 + 2) // except data

  uint32_t egg_packet_calculate_encode_size(struct egg_packet_t * packet) {
    return base64_encode_length(egg_payload_calculate_size(&packet->payload)) + EGG_PACKET_META_SIZE;
  }

  uint32_t egg_packet_encode(struct egg_packet_t * packet, uint8_t * buf, uint32_t size) {
    uint32_t payload_size = egg_payload_calculate_size(&packet->payload);
    uint8_t zbuf[payload_size];
    int zsize = egg_payload_encode_zeropack(&packet->payload, zbuf, payload_size);

    uint32_t base64_len = base64_encode(zbuf, zsize, buf + EGG_PACKET_META_SIZE, size - EGG_PACKET_META_SIZE);
    if (base64_len == 0) return 0;
    buf[0] = 0x33;
    buf[1] = 0x3C;
    buf[2] = 0xC3;
    buf[3] = 0xCC;
    buf[8] = packet->egg;
    buf[9] = packet->version;
    buf[10] = base64_len & 0xFF;
    buf[11] = (base64_len >> 8) & 0xFF;
    uint32_t checksum = adler32(buf + 8, base64_len + 4 /* egg + version + data length */);
    buf[4] = checksum & 0xFF;
    buf[5] = (checksum >> 8) & 0xFF;
    buf[6] = (checksum >> 16) & 0xFF;
    buf[7] = (checksum >> 24) & 0xFF;
    return EGG_PACKET_META_SIZE + base64_len;
  }

  uint32_t egg_packet_estimate_decode_size(uint8_t * buf, uint32_t size) {
    if (size <= EGG_PACKET_META_SIZE) return 0;
    if (buf[0] != 0x33 ||
        buf[1] != 0x3C ||
        buf[2] != 0xC3 ||
        buf[3] != 0xCC) {
      return 0;
    }
    uint32_t len = (buf[10] + (buf[11] << 8)) & 0xFFFF;
    uint32_t checksum = adler32(buf + 8, len + 4);
    if ((buf[4] == (checksum & 0xFF)) &&
        (buf[5] == ((checksum >> 8) & 0xFF)) &&
        (buf[6] == ((checksum >> 16) & 0xFF)) &&
        (buf[7] == ((checksum >> 24) & 0xFF))) {
      uint32_t zlen = base64_decode_length(buf + EGG_PACKET_META_SIZE, len);
      if (zlen == 0) return 0;
      uint8_t zbuf[zlen];
      base64_decode(buf + EGG_PACKET_META_SIZE, len, zbuf, zlen);
      return egg_payload_estimate_zeropack_size(zbuf, zlen) + EGG_PACKET_META_SIZE;
    }
    return 0;
  }

  egg_cmd_type_t egg_packet_decode(uint8_t * buf, uint32_t size, struct egg_packet_t * packet) {
    if (size < EGG_PACKET_META_SIZE) return 0;
    if (buf[0] != 0x33 ||
        buf[1] != 0x3C ||
        buf[2] != 0xC3 ||
        buf[3] != 0xCC) {
      return 0;
    }
    uint32_t len = (buf[10] + (buf[11] << 8)) & 0xFFFF;
    uint32_t checksum = adler32(buf + 8, len + 4);
    if ((buf[4] == (checksum & 0xFF)) &&
        (buf[5] == ((checksum >> 8) & 0xFF)) &&
        (buf[6] == ((checksum >> 16) & 0xFF)) &&
        (buf[7] == ((checksum >> 24) & 0xFF))) {
      uint32_t zlen = base64_decode_length(buf + EGG_PACKET_META_SIZE - 1, len);
      if (zlen == 0) return 0;
      uint8_t zbuf[zlen];
      zlen = base64_decode(buf + EGG_PACKET_META_SIZE, len, zbuf, zlen);
      uint32_t dlen = egg_payload_estimate_zeropack_size(zbuf, zlen);
      uint8_t dbuf[dlen];
      egg_payload_decode_zeropack(zbuf, zlen, dbuf, &packet->payload);
      packet->version = buf[9];
      packet->egg = buf[8];
      return packet->payload.cmd;
    }
    return 0;
  }
#+end_src
