#+STARTUP: indent
* 通讯协议
** 通讯命令

 | no | cmd      | 说明      |
 |----+----------+-----------|
 |  0 | UNKNOWN  | 未知命令  |
 |  1 | ACK      | 响应      |
 | 27 | LOCK-OFF | 开锁      |
 | 26 | LOCK-ON  | 关锁      |
 | 28 | PLAY     | 播放语音  |
 | 29 | GPIO     | 设置 GPIO |
 | 30 | FALLEN   | 掉落通知  |
 | 31 | VOLUME   | 设置音量  |
 | 32 | TIMEOUT  | 超时通知  |
 | 33 | QUERY    | 查询状态  |

#+begin_src c :noweb-ref command-type
  typedef enum EGG_CMD_TYPE {
    EGG_UNKNOWN = 0x00,
    EGG_ACK = 0x01,
    EGG_LOCK_OFF= 0x1B,
    EGG_LOCK_ON = 0x1A,
    EGG_PLAY = 0x1C,
    EGG_GPIO = 0x1D,
    EGG_FALLEN = 0x1E,
    EGG_VOLUME = 0x1F,
    EGG_TIMEOUT = 0x20,
    EGG_QUERY = 0x21,
  } egg_cmd_type_t;
#+end_src

** 数据结构

*** 数据包

#+begin_src c :noweb-ref packet
  struct egg_packet_t {
    uint8_t egg;
    uint8_t version;
    egg_payload_t payload;
  };
#+end_src


*** 负载

#+begin_src lisp :mkdirp yes :tangle /dev/shm/eggos/protocol.tr
  (struct egg-payload
    (int 0 sn)
    (byte 1 cmd)
    (int 2 timestamp)
    (byte 3 ack-type)
    (byte 4 cabin)
    (int 5 audio)
    (byte 6 gpio)
    (byte 7 volume)
    (byte 8 busy)
    )
#+end_src

命令与数据矩阵

| cmd      | cabin | audio | gpio | volume |
|----------+-------+-------+------+--------|
| LOCK OFF | ✓     |       |      |        |
| LOCK ON  | ✓     |       |      |        |
| PLAY     |       | ✓     |      |        |
| GPIO     |       |       | ✓    |        |
| FALLEN   | ✓     |       |      |        |
| VOLUME   |       |       |      | ✓      |
| TIMEOUT  | ✓     |       |      |        |
| QUERY    | ✓     |       |      |        |

** 数据封包

#+begin_src c :mkdirp yes :noweb yes :tangle /dev/shm/eggos/egg_packet.h
  #ifndef __EGG_PACKET_H
  #define __EGG_PACKET_H
  #include <stdint.h>
  #include "egg_payload.h"
  #define EGG 2 /* device type */
  <<command-type>>
  <<packet>>
  uint32_t egg_packet_calculate_encode_size(struct egg_packet_t * packet);
  uint32_t egg_packet_encode(struct egg_packet_t * packet, uint8_t * buf, uint32_t size);
  uint32_t egg_packet_estimate_decode_size(uint8_t * buf, uint32_t size);
  egg_cmd_type_t egg_packet_decode(uint8_t * buf, uint32_t size, uint32_t estimated, struct egg_packet_t * packet);
  #endif
#+end_src

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/egg_packet.c
  #include "egg_packet.h"
  #include "hash.h"

  /*
    packet layout:

            +-+-+-+-+-+-+-+-+
    byte 0  |0|0|1|1|0|0|1|1|   magic number 0
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 1  |0|0|1|1|1|1|0|0|   magic number 1
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 2  |1|1|0|0|0|0|1|1|   magic number 2
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 3  |1|1|0|0|1|1|0|0|   magic number 3
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 4  |x|x|x|x|x|x|x|x|   adle32-0 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 5  |x|x|x|x|x|x|x|x|   adle32-1 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 6  |x|x|x|x|x|x|x|x|   adle32-2 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 7  |x|x|x|x|x|x|x|x|   adle32-3 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 8  |x|x|x|x|x|x|x|x|   device type
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 9  |0|0|0|0|0|x|x|x|   egg no
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte A  |0|0|0|0|0|0|0|0|   version
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte B  |x|x|x|x|x|x|x|x|   length0 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte C  |x|x|x|x|x|x|x|x|   length1 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte D  |x|x|x|x|x|x|x|x|   begin of data (base64)
            +-+-+-+-+-+-+-+-+
                    .
                    .
                    .
            +-+-+-+-+-+-+-+-+
    byte n  |x|x|x|x|x|x|x|x|   end of data (base64)
            +-+-+-+-+-+-+-+-+

  ,*/

  #define EGG_PACKET_META_SIZE (4 + 4 + 1 + 1 + 1 + 2) // except data

  uint32_t egg_packet_calculate_encode_size(struct egg_packet_t * packet) {
    return egg_payload_calculate_size(&packet->payload) + EGG_PACKET_META_SIZE;
  }

  uint32_t egg_packet_encode(struct egg_packet_t * packet, uint8_t * buf, uint32_t size) {
    int realsize = egg_payload_encode_zeropack(&packet->payload, buf + EGG_PACKET_META_SIZE, size - EGG_PACKET_META_SIZE);

    if (realsize == 0) return 0;
    buf[0] = 0xCC;
    buf[1] = 0xC3;
    buf[2] = 0x3C;
    buf[3] = 0x33;
    buf[8] = EGG;
    buf[9] = packet->egg;
    buf[10] = packet->version;
    buf[11] = realsize & 0xFF;
    buf[12] = (realsize >> 8) & 0xFF;
    uint32_t checksum = adler32(buf + 8, realsize + 5 /* type + egg + version + data length */);
    buf[4] = checksum & 0xFF;
    buf[5] = (checksum >> 8) & 0xFF;
    buf[6] = (checksum >> 16) & 0xFF;
    buf[7] = (checksum >> 24) & 0xFF;
    return EGG_PACKET_META_SIZE + realsize;
  }

  uint32_t egg_packet_estimate_decode_size(uint8_t * buf, uint32_t size) {
    if (size <= EGG_PACKET_META_SIZE) return 0;
    if (buf[0] != 0xCC ||
        buf[1] != 0xC3 ||
        buf[2] != 0x3C ||
        buf[3] != 0x33 ||
        buf[8] != EGG) {
      return 0;
    }
    uint32_t len = (buf[11] + (buf[12] << 8)) & 0xFFFF;
    uint32_t checksum = adler32(buf + 8, len + 5);
    if ((buf[4] == (checksum & 0xFF)) &&
        (buf[5] == ((checksum >> 8) & 0xFF)) &&
        (buf[6] == ((checksum >> 16) & 0xFF)) &&
        (buf[7] == ((checksum >> 24) & 0xFF))) {
      return egg_payload_estimate_zeropack_size(buf + EGG_PACKET_META_SIZE, len) + EGG_PACKET_META_SIZE;
    }
    return 0;
  }

  egg_cmd_type_t egg_packet_decode(uint8_t * buf, uint32_t size, uint32_t estimated, struct egg_packet_t * packet) {
    if (size < EGG_PACKET_META_SIZE) return 0;
    if (buf[0] != 0xCC ||
        buf[1] != 0xC3 ||
        buf[2] != 0x3C ||
        buf[3] != 0x33 ||
        buf[8] != EGG) {
      return 0;
    }
    uint32_t len = (buf[11] + (buf[12] << 8)) & 0xFFFF;
    uint32_t checksum = adler32(buf + 8, len + 5);
    if ((buf[4] == (checksum & 0xFF)) &&
        (buf[5] == ((checksum >> 8) & 0xFF)) &&
        (buf[6] == ((checksum >> 16) & 0xFF)) &&
        (buf[7] == ((checksum >> 24) & 0xFF))) {
      uint8_t dbuf[estimated];
      egg_payload_decode_zeropack(buf + EGG_PACKET_META_SIZE, size, dbuf, &packet->payload);
      packet->egg = buf[9];
      packet->version = buf[10];
      return packet->payload.cmd;
    }
    return 0;
  }
#+end_src
