#+TITLE: The core application for egg machine based on STM32F030
#+AUTHOR: Titan
#+EMAIL: howay.tan@fengchaohuzhu.com
#+DATE: <2018-07-11 Wed>
#+KEYWORDS: stm32, cortex m0, egg machine
#+OPTIONS: H:4 toc:t
#+STARTUP: indent

* 核心代码
** 基本框架
#+begin_src c :noweb yes :mkdirp yes :tangle /dev/shm/eggos/eggos.c
  #include <libopencm3/stm32/iwdg.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/cm3/nvic.h>
  #include <libopencm3/cm3/systick.h>
  #include <stddef.h>
  #include <stdint.h>
  #include "defination.h"
  #include "egg-fsm.h"
  #include "repl.h"
  #include "epigyny.h"
  #include "uart.h"
  #include "lock.h"
  #include "infrared.h"
  #include "speaker.h"
  #include "gpio.h"
  #include "led.h"
  #include "stack.h"

  #define EGG_STACK_BUFFER_BITSIZE  4

  volatile uint32_t systick = 0;
  uint16_t locking_off_cabins = 0;
  uint32_t slot = 0;
  uint32_t egg_states[16] = {EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE, EGG_LOCKING_ON_STATE};
  uint32_t locking_timers[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  uint32_t delaying_timers[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  struct stack_t egg_stack;
  static uint8_t egg_stack_buffer[2 << (EGG_STACK_BUFFER_BITSIZE - 1)];

  <<sys-tick-handler>>

  static void setup(void) {
    stack_init(&egg_stack, egg_stack_buffer, EGG_STACK_BUFFER_BITSIZE);
    <<setup-systick>>
    <<setup-epigyny>>
    <<setup-repl>>
    uart_setup();
    <<setup-lock>>
    <<setup-infrared>>
    <<setup-speaker>>
    <<setup-gpio>>
    <<setup-led>>
  }

  <<egg-fsm-action>>

  int main(void) {
    setup();
    uint32_t loop_timer = systick;

    while (1) {
      // main loop
      infrared_eventloop();
      uart_eventloop();
      speaker_eventloop();
      <<main-loop>>
    }
    return 0;
  }
#+end_src
** 配置
*** 时钟
systick 设置为每 1 毫秒自增一次。
#+begin_src c :noweb-ref setup-systick
  rcc_clock_setup_in_hsi_out_48mhz();

  /* 48MHz => 48000000 counts per second */
  systick_set_clocksource(STK_CSR_CLKSOURCE_AHB);

  /* 48,000,000/48,000 = 1000 overflows per second - every 1ms one interrupt */
  /* SysTick interrupt every N clock pulses: set reload to N-1 */
  systick_set_reload(47999);
  systick_interrupt_enable();
  systick_counter_enable();
#+end_src

#+begin_src c :noweb-ref sys-tick-handler
  void sys_tick_handler(void) {
    systick ++;
  }
#+end_src
*** REPL通讯串口
REPL通讯挂在串口1上。

#+begin_src c :noweb-ref setup-repl
  repl_uart_context.setup = repl_setup;
  repl_uart_context.eventloop = repl_eventloop;

  uart_init(1, &repl_uart_context);
#+end_src

*** 上位机通讯串口
上位机通讯挂在串口2上。

#+begin_src c :noweb-ref setup-epigyny
  epigyny_uart_context.setup = epigyny_setup;
  epigyny_uart_context.eventloop = epigyny_eventloop;

  uart_init(2, &epigyny_uart_context);
#+end_src

*** 锁控
#+begin_src c :noweb-ref setup-lock
  lock_setup();
#+end_src
*** 红外检测
#+begin_src c :noweb-ref setup-infrared
  infrared_setup();
#+end_src
*** 音频
#+begin_src c :noweb-ref setup-speaker
  speaker_setup();
#+end_src
*** GPIO
#+begin_src c :noweb-ref setup-gpio
  gpio_setup();
#+end_src
*** LED
#+begin_src c :noweb-ref setup-led
  led_setup();
#+end_src
** 主循环
在初始化完成后，系统进入主循环，根据当前的状态和发生的事件，推动状态机
运行。
#+begin_src c :noweb-ref main-loop
  if (UINT32_DIFF_GREATER_THAN(systick, loop_timer, 999)) {
    loop_timer = systick;
    for (uint8_t i = 0; i < 16; i ++) {
      if (egg_states[i] == EGG_DELAYING_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, delaying_timers[i], 199)) {
          egg_states[i] = egg_transform_state(egg_states[i], EGG_DELAY_TIMEOUT_EVENT, &i);
        }
      } else if (egg_states[i] == EGG_LOCKING_OFF_1M_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, locking_timers[i], 59999)) {
          egg_states[i] = egg_transform_state(egg_states[i], EGG_1_MINUTE_TIMEOUT_EVENT, &i);
        }
      } else if (egg_states[i] == EGG_LOCKING_OFF_2M_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, locking_timers[i], 119999)) {
          egg_states[i] = egg_transform_state(egg_states[i], EGG_2_MINUTES_TIMEOUT_EVENT, &i);
        }
      } else if (egg_states[i] == EGG_LOCKING_OFF_3M_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, locking_timers[i], 179999)) {
          egg_states[i] = egg_transform_state(egg_states[i], EGG_3_MINUTES_TIMEOUT_EVENT, &i);
        }
      }
    }
    if (locking_off_cabins == 0) {
      led_off();
    } else {
      led_on();
    }
  }
#+end_src

** 核心状态机
核心流程：

1. 接收到开锁指令，开锁。

2. 延迟 200 MS 开始检查落蛋事件，这样是为了绕开因开锁的干扰导致检测到
   的落蛋事件。

3. 若 1 分钟内未检测到落蛋事件，播放提示语音。

4. 若 2 分钟内未检测到落蛋事件，播放提示语音。

5. 若 3 分钟内未检测到落蛋事件，播放提示语音并关锁。

6. 在开锁后（含延迟 200 MS）三分钟内的任意时刻，检测到落蛋事件，播放提
   示语音并关锁。

核心状态机的定义见 egg-fsm.xlsx 文件。
#+begin_src c :noweb-ref egg-fsm-action
  void egg_do_action(enum EGG_ACTION action, void * data) {
    uint8_t cabin = * (uint8_t *) data;
    switch (action) {
    case EGG_PLAY_WELCOME_NEWLINE_LOCK_OFF_ACTION:
      lock_off(cabin);
      speaker_play(1);
      locking_timers[cabin] = systick;
      delaying_timers[cabin] = systick;
      break;
    case EGG_LOCK_ON_ACTION:
      lock_on(cabin);
      break;
    case EGG_PLAY_GOODBYE_NEWLINE_LOCK_ON_NEWLINE_FALLEN_ACTION:
      lock_on(cabin);
      epigyny_fallen(cabin);
      speaker_play(2);
      break;
    case EGG_PLAY_3M_NEWLINE_LOCK_ON_ACTION:
      lock_on(cabin);
      speaker_play(5);
      break;
    case EGG_PLAY_1M_ACTION:
      speaker_play(3);
      break;
    case EGG_PLAY_2M_ACTION:
      speaker_play(4);
      break;
    }
  }
#+end_src
* 上位机处理
上位机处理部分执行并响应上位机下发的指令。
** 基本框架
#+begin_src c :noweb yes :mkdirp yes :tangle /dev/shm/eggos/epigyny.h
  #ifndef __EPIGYNY_H
  #define __EPIGYNY_H
  #include "uart.h"

  extern struct uart_context_t epigyny_uart_context;

  void epigyny_setup(struct uart_context_t * ctx);
  void epigyny_eventloop(struct uart_context_t * ctx);
  <<fallen-prototype>>
  #endif
#+end_src
#+begin_src c :noweb yes :mkdirp yes :tangle /dev/shm/eggos/epigyny.c
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/usart.h>
  #include <libopencm3/cm3/nvic.h>
  #include <stddef.h>
  #include "defination.h"
  #include "epigyny.h"
  #include "egg_packet.h"
  #include "uart.h"
  #include "ring.h"
  #include "utility.h"
  #include "egg-fsm.h"
  #include "egg-proto-fsm.h"
  #include "speaker.h"
  #include "gpio.h"

  #define EPIGYNY_BUFFER_BITSIZE 8

  static struct ring_t epigyny_tx;
  static struct ring_t epigyny_rx;
  static uint8_t epigyny_tx_buffer[2 << (EPIGYNY_BUFFER_BITSIZE - 1)];
  static uint8_t epigyny_rx_buffer[2 << (EPIGYNY_BUFFER_BITSIZE - 1)];
  struct uart_context_t epigyny_uart_context;
  static uint32_t egg_proto_state;

  <<proto-context>>

  static struct egg_proto_context_t context;
  <<epigyny-setup>>
  <<epigyny-eventloop>>
  <<proto-callback>>
  <<egg-proto-fsm-action>>
  <<fallen>>
#+end_src
** 配置
#+begin_src c :noweb-ref epigyny-setup
  void epigyny_setup(struct uart_context_t * ctx) {
    ring_init(&epigyny_tx, epigyny_tx_buffer, EPIGYNY_BUFFER_BITSIZE);
    ring_init(&epigyny_rx, epigyny_rx_buffer, EPIGYNY_BUFFER_BITSIZE);
    ctx->tx = &epigyny_tx;
    ctx->rx = &epigyny_rx;
    ctx->baudrate = 9600;
    ctx->databits = 8;
    ctx->stopbits = 1;
    ctx->tx_interval = 99; // 100ms
    ctx->loop_interval = 999; // 1s
    ctx->slot_enabled = 1;
    ctx->manual = 1;
    ctx->flow_rcc = RCC_GPIOF;
    ctx->flow_port = GPIOF;
    ctx->flow_io = GPIO4;
    bzero(&context, sizeof(struct egg_proto_context_t));
    egg_proto_state = EGG_PROTO_READY_STATE;
  }
#+end_src
** 主循环
在主循环中，程序要检查 RX 中收到的数据。所有收到的数据要送到协议状态机
中进行处理。当协议状态机发现接收的是完成数据包时，调用回调函数对上位机
的命令进行处理。
#+begin_src c :noweb-ref epigyny-eventloop
  void epigyny_eventloop(struct uart_context_t * uartctx) {
    struct ring_t * rx = uartctx->rx;
    uint32_t rxlen = ring_length(rx);
    struct egg_proto_context_t * ctx = &context;
    if (rxlen > 0) {
      ctx->rx_timer = systick;
      for (uint32_t i = 0; i < rxlen; i ++) {
        if (ctx->countdown <= 0xFFFF) {
          ctx->countdown --;
        }
        uint8_t byte;
        ring_read(rx, &byte);
        ctx->byte = byte;
        if (byte == 0x00) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X00_EVENT, ctx);
        } else if (0x01 <= byte && byte <= 0x32) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X01_MINUS_0X32_EVENT, ctx);
        } else if (byte == 0x33) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X33_EVENT, ctx);
        } else if (0x34 <= byte && byte <= 0x3B) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X34_MINUS_0X3B_EVENT, ctx);
        } else if (byte == 0x3C) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X3C_EVENT, ctx);
        } else if (0x3D <= byte && byte <= 0xC2) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X3D_MINUS_0XC2_EVENT, ctx);
        } else if (byte == 0xC3) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XC3_EVENT, ctx);
        } else if (0xC4 <= byte && byte <= 0xCB) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XC4_MINUS_0XCB_EVENT, ctx);
        } else if (byte == 0xCC) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XCC_EVENT, ctx);
        } else if (0xCD <= byte) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XCD_MINUS_0XFF_EVENT, ctx);
        }
        if (ctx->countdown == 0) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_COUNTDOWN_EQUALS_0_EVENT, ctx);
        }
      }
    }

    if (ctx->rx_timer != 0xFFFFFFFF && (UINT32_DIFF_GREATER_THAN(systick, ctx->rx_timer, 99))) { // 1s
      egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_EOF_EVENT, ctx);
      ctx->rx_timer = 0xFFFFFFFF;
    }
  }
#+end_src
** 协议状态机
协议状态机用于解析从上位机发送来的数据。协议状态机的定义见
egg-proto-fsm.xlsx 文件。

#+begin_src c :noweb-ref egg-proto-fsm-action
  void egg_proto_do_action(enum EGG_PROTO_ACTION action, void * data) {
    struct egg_proto_context_t * ctx = (struct egg_proto_context_t *) data;
    switch (action) {
    case EGG_PROTO_APPEND_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      break;
    case EGG_PROTO_CLEAR_ACTION:
      bzero(ctx, sizeof(struct egg_proto_context_t));
      ctx->countdown = (uint32_t) 0xFFFFFFFF;
      break;
    case EGG_PROTO_APPEND_AND_SAVE_TYPE_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      ctx->type = ctx->byte;
      break;
    case EGG_PROTO_APPEND_AND_SAVE_LEN0_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      ctx->len0 = ctx->byte;
      break;
    case EGG_PROTO_APPEND_AND_SAVE_LEN1_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      ctx->len1 = ctx->byte;
      ctx->countdown = ((ctx->len1 << 8) | ctx->len0) & 0xFFFF;
      break;
    case EGG_PROTO_CALLBACK_ACTION:
      epigyny_callback(ctx->buf, ctx->ptr);
      bzero(ctx, sizeof(struct egg_proto_context_t));
      ctx->countdown = (uint32_t) 0xFFFFFFFF;
      break;
    }
  }
#+end_src

** 协议解析上下文
解析上下文里要存放在解析过程中用到的临时数据。
| name      | type   |                                                                                 |
|-----------+--------+---------------------------------------------------------------------------------|
| buf       | [byte] | 解析过程中使用的缓冲区                                                          |
| ptr       | uint32 | 记录可用缓冲区的位置                                                            |
| byte      | byte   | 解析的当前数据                                                                  |
| len0      | byte   | 包中 base64 内容的数据长度的低 8 位                                             |
| len1      | byte   | 包中 base64 内容的数据长度的高 8 位                                             |
| countdown | uint32 | 剩余应读取的 base64 内容的长度。为 0 时产生 countdown = 0 事件。                |
| rx_timer  | uint32 | 最后一次接收到数据的时间戳。当前事件与 rx_timer 差异大于 1000 时，产生 EOF 事件 |

#+begin_src c :noweb-ref proto-context
  struct egg_proto_context_t {
    uint8_t buf[512];
    uint32_t ptr;
    uint8_t byte;
    uint8_t type;
    uint8_t len0;
    uint8_t len1;
    uint32_t countdown;
    uint32_t rx_timer;
  };
#+end_src
** 协议回调

协议上的 cabin 是从 1 开始计数的，在使用时，必须先变成从 0 开始计数的。
#+begin_src c :noweb-ref proto-callback
  #include "repl.h"
  static void epigyny_callback(uint8_t * buf, uint32_t size) {

    if (buf[8] == 0xFF) {
      slot = systick + 100 * EGGID;
      return;
    }

    if (buf[8] != EGG) {
      // it's not my device type, skip it
      return;
    }

    if (buf[9] != EGGID && buf[9] != 0xFF) {
      // it's not my packet, skip it
      return;
    }

    uint32_t len = egg_packet_estimate_decode_size(buf, size);
    uint8_t tmp[len];
    bzero(tmp, len);
    struct egg_packet_t * packet = (struct egg_packet_t *) &tmp;

    struct egg_packet_t ackpacket;
    bzero(&ackpacket, sizeof(struct egg_packet_t));
    ackpacket.egg = EGGID;
    ackpacket.payload.cmd = EGG_ACK;

    uint32_t cmd = egg_packet_decode(buf, size, len, packet);
    ackpacket.payload.sn = packet->payload.sn;

    switch (cmd) {
    case EGG_LOCK_OFF: {
      uint8_t cabin = packet->payload.cabin - 1;
      if (cabin < 16) {
        egg_states[cabin] = egg_transform_state(egg_states[cabin], EGG_LOCK_OFF_EVENT, &cabin);
        ackpacket.payload.ack_type = EGG_LOCK_OFF;
        ackpacket.payload.cabin = packet->payload.cabin;
      }
      break;
    }
    case EGG_LOCK_ON: {
      uint8_t cabin = packet->payload.cabin - 1;
      if (cabin < 16) {
        egg_states[cabin] = egg_transform_state(egg_states[cabin], EGG_LOCK_ON_EVENT, &cabin);
        ackpacket.payload.ack_type = EGG_LOCK_ON;
        ackpacket.payload.cabin = packet->payload.cabin;
      }
      break;
    }
    case EGG_PLAY:
      speaker_play(packet->payload.audio);
      ackpacket.payload.ack_type = EGG_PLAY;
      ackpacket.payload.audio = packet->payload.audio;
      break;
    case EGG_GPIO:
      gpio_exclamation_mark(packet->payload.gpio);
      ackpacket.payload.ack_type = EGG_GPIO;
      ackpacket.payload.gpio = packet->payload.gpio;
      break;
    default:
      break;
    }

    uint32_t acklen = egg_packet_calculate_encode_size(&ackpacket);
    uint8_t size_of_len = 0;
    if (acklen < 128) {
      size_of_len = 1;
    } else if (acklen < 16384) {
      size_of_len = 2;
    } else if (acklen < 2097152) {
      size_of_len = 3;
    } else {
      size_of_len = 4;
    }
    if (ring_available(&epigyny_tx) >= acklen + size_of_len) {
      uint8_t ackbuf[acklen];
      bzero(ackbuf, acklen);
      uint32_t reallen = egg_packet_encode(&ackpacket, ackbuf, acklen);
      acklen = reallen;
      while (acklen > 0) {
        ring_write(&epigyny_tx, acklen & 0x7F);
        acklen = acklen >> 7;
      }
      ring_write_array(&epigyny_tx, ackbuf, 0, reallen);
    }

  }
#+end_src

** 落蛋上报
#+begin_src c :noweb-ref fallen-prototype
  void epigyny_fallen(uint8_t cabin);
#+end_src

#+begin_src c :noweb-ref fallen
  void epigyny_fallen(uint8_t cabin) {
    struct egg_packet_t packet;
    bzero(&packet, sizeof(struct egg_packet_t));
    packet.egg = EGGID;
    packet.payload.cmd = EGG_FALLEN;
    packet.payload.cabin = cabin + 1;
    uint32_t len = egg_packet_calculate_encode_size(&packet);
    uint8_t size_of_len = 0;
    if (len < 128) {
      size_of_len = 1;
    } else if (len < 16384) {
      size_of_len = 2;
    } else if (len < 2097152) {
      size_of_len = 3;
    } else {
      size_of_len = 4;
    }
    if (ring_available(&epigyny_tx) >= len + size_of_len) {
      uint8_t buf[len];
      bzero(buf, len);
      uint32_t reallen = egg_packet_encode(&packet, buf, len);
      len = reallen;
      while (len > 0) {
        ring_write(&epigyny_tx, len & 0x7F);
        len = len >> 7;
      }
      ring_write_array(&epigyny_tx, buf, 0, reallen);
    }
  }
#+end_src
* 驱动代码
** 串口
#+begin_src c :tangle /dev/shm/eggos/uart.h
  #ifndef __UART_H
  #define __UART_H
  #include <stdint.h>
  #include "ring.h"
  struct uart_context_t;
  typedef void (* uart_setup_fn)(struct uart_context_t * ctx);
  typedef void (* uart_eventloop_fn)(struct uart_context_t * ctx);
  struct uart_context_t {
    uint32_t baudrate;
    uint8_t databits, stopbits;
    struct ring_t * tx, * rx;
    uint32_t loop_timer;
    uint32_t loop_interval;
    uint32_t tx_timer;
    uint32_t tx_interval;
    uint32_t tx_to_send;
    uint8_t slot_enabled;
    uint8_t manual;
    uint32_t flow_port;
    uint32_t flow_io;
    uint32_t flow_rcc;
    //uint8_t uart;
    uart_setup_fn setup;
    uart_eventloop_fn eventloop;
  };

  void uart_init(uint8_t idx, struct uart_context_t * ctx);
  void uart_setup(void);
  void uart_start(void);
  void uart_eventloop(void);
  struct uart_context_t * uart_context(uint8_t idx);
  #endif
#+end_src

#+begin_src c :tangle /dev/shm/eggos/uart.c
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/usart.h>
  #include <libopencm3/cm3/nvic.h>
  #include <stddef.h>
  #include "defination.h"
  #include "uart.h"

  static int RCC_UART[2] = {
    RCC_USART1,
    RCC_USART2,
  };

  static int RCC_UART_GPIO[2] = {
    RCC_GPIOB,
    RCC_GPIOA,
  };

  static uint8_t NVIC_UART_IRQ[2] = {
    NVIC_USART1_IRQ,
    NVIC_USART2_IRQ,
  };

  static uint32_t TX_GPIO_PORT[2] = {
    GPIOB,
    GPIOA,
  };

  static uint32_t RX_GPIO_PORT[2] = {
    GPIOB,
    GPIOA,
  };

  static int TX_GPIO_IO[2] = {
    GPIO6,
    GPIO2,
  };

  static int RX_GPIO_IO[2] = {
    GPIO7,
    GPIO3,
  };

  static uint32_t UART[2] = {
    USART1,
    USART2,
  };

  static uint32_t GPIO_AF[2] = {
    GPIO_AF0,
    GPIO_AF1,
  };

  struct uart_context_t * ctxs[2] = { NULL, NULL };

  void uart_init(uint8_t idx, struct uart_context_t * ctx) {
    ctxs[idx - 1] = ctx;
  }

  void uart_setup() {
    for (uint8_t i = 0; i < 2; i ++) {
      if (ctxs[i] != NULL) {
        ctxs[i]->setup(ctxs[i]);

        rcc_periph_clock_enable(RCC_UART[i]);
        rcc_periph_clock_enable(RCC_UART_GPIO[i]);

        nvic_enable_irq(NVIC_UART_IRQ[i]);

        gpio_mode_setup(TX_GPIO_PORT[i], GPIO_MODE_AF, GPIO_PUPD_NONE, TX_GPIO_IO[i]);
        gpio_mode_setup(RX_GPIO_PORT[i], GPIO_MODE_AF, GPIO_PUPD_NONE, RX_GPIO_IO[i]);

        gpio_set_af(TX_GPIO_PORT[i], GPIO_AF[i], TX_GPIO_IO[i]);
        gpio_set_af(RX_GPIO_PORT[i], GPIO_AF[i], RX_GPIO_IO[i]);
        if (ctxs[i]->manual == 1) {
          rcc_periph_clock_enable(ctxs[i]->flow_rcc);
          gpio_mode_setup(ctxs[i]->flow_port, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, ctxs[i]->flow_io);
          gpio_clear(ctxs[i]->flow_port, ctxs[i]->flow_io);
        }

        /* Setup UART parameters. */
        usart_set_baudrate(UART[i], ctxs[i]->baudrate);
        usart_set_databits(UART[i], ctxs[i]->databits);
        usart_set_stopbits(UART[i], ctxs[i]->stopbits);
        usart_set_mode(UART[i], USART_MODE_TX_RX);
        usart_set_parity(UART[i], USART_PARITY_NONE);
        usart_set_flow_control(UART[i], USART_FLOWCONTROL_NONE);

        /* Enable receive interrupt. */
        USART_CR1(UART[i]) |= USART_CR1_RXNEIE;

        /* Finally enable the USART. */
        usart_enable(UART[i]);
      }
    }
  }

  void uart_eventloop() {
    for (uint8_t i = 0; i < 2; i ++) {
      struct uart_context_t * ctx = ctxs[i];
      if (ctx != NULL) {
        if (UINT32_DIFF_GREATER_THAN(systick, ctx->loop_timer, ctx->loop_interval)) {
          ctx->loop_timer = systick;
          ctx->eventloop(ctx);
        }
        if (UINT32_DIFF_GREATER_THAN(systick, ctx->tx_timer, ctx->tx_interval)) {
          ctx->tx_timer = systick;
          if (ctx->tx_to_send == 0) {
            if (ring_length(ctx->tx) > 1) {
              // saved length as varint type
              uint32_t len = 0;
              uint8_t byte = 0;
              uint8_t count = 0;
              ring_read(ctx->tx, &byte);
              while (byte > 127 && ring_length(ctx->tx) > 0) {
                ring_read(ctx->tx, &byte);
                len |= (byte & 0x7F) << (count * 7);
                count ++;
              }
              len |= (byte & 0x7F) << (count * 7);

              ctx->tx_to_send = len;
            }
          } else if (ctx->slot_enabled == 1) {
            if (UINT32_DIFF_GREATER_THAN(systick, slot, 0) && (UINT32_DIFF_GREATER_THAN(slot + 100, systick, 0))) {
              if (ctx->manual == 1) {
                gpio_set(ctx->flow_port, ctx->flow_io);
              }
              USART_CR1(UART[i]) |= USART_CR1_TXEIE;
            } else {
              USART_CR1(UART[i]) &= ~USART_CR1_TXEIE;
              if (ctx->manual == 1) {
                gpio_clear(ctx->flow_port, ctx->flow_io);
              }
            }
          } else {
            if (ctx->manual == 1) {
              gpio_set(ctx->flow_port, ctx->flow_io);
            }
            USART_CR1(UART[i]) |= USART_CR1_TXEIE;
          }
        }
      }
    }
  }

  struct uart_context_t * uart_context(uint8_t idx) {
    return ctxs[idx - 1];
  }

  static void uart_isr(uint8_t idx) {

    uint8_t data = 0;
    uint32_t result = 0;

    struct uart_context_t * ctx = ctxs[idx];
    if (ctx == NULL) return;

    /* Check if we were called because of RXNE. */
    if (((USART_CR1(UART[idx]) & USART_CR1_RXNEIE) != 0) && ((USART_ISR(UART[idx]) & USART_ISR_RXNE) != 0)) {

      /* Retrieve the data from the peripheral. */
      data = usart_recv(UART[idx]);
      ring_write(ctx->rx, data);
      if (ring_available(ctx->rx) == 0) {
        /* Disable the RXNEIE interrupt */
        USART_CR1(UART[idx]) &= ~USART_CR1_RXNEIE;
      }
    }

    /* Check if we were called because of TXE. */
    if (((USART_CR1(UART[idx]) & USART_CR1_TXEIE) != 0) && ((USART_ISR(UART[idx]) & USART_ISR_TXE) != 0)) {
      if (ctx->tx_to_send == 0) {
        USART_CR1(UART[idx]) &= ~USART_CR1_TXEIE;
        if (ctx->manual == 1) {
          /* Enable transmission complete interrupt. */
          USART_CR1(UART[idx]) |= USART_CR1_TCIE;
        }

        return;
      }

      result = ring_read(ctx->tx, &data);

      if (result == 0) {
        /* Disable the TXE interrupt, it's no longer needed. */
        USART_CR1(UART[idx]) &= ~USART_CR1_TXEIE;
      } else {
        /* Put data into the transmit register. */
        usart_send(UART[idx], data);
        ctx->tx_to_send --;
      }
    }

    /* Check if we were called because of TC. */
    if (((USART_CR1(UART[idx]) & USART_CR1_TCIE) != 0) && ((USART_ISR(UART[idx]) & USART_ISR_TC) != 0)) {
      if (ctx->tx_to_send == 0) {
        USART_CR1(UART[idx]) &= ~USART_CR1_TCIE;
        gpio_clear(ctx->flow_port, ctx->flow_io);
        return;
      }
    }
  }

  void usart1_isr(void) {
    uart_isr(1 - 1);
  }

  void usart2_isr(void) {
    uart_isr(2 - 1);
  }
#+end_src
** 锁控
#+begin_src c :tangle /dev/shm/eggos/lock.h
  #ifndef __LOCK_H
  #define __LOCK_H
  #include <stdint.h>

  void lock_setup(void);
  void lock_off(uint8_t cabin);
  void lock_on(uint8_t cabin);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/lock.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "lock.h"
  #include "defination.h"

  static uint32_t ports[16] = {GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOC, GPIOC, GPIOC, GPIOC, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB};
  static uint32_t ios[16] = {GPIO12, GPIO11, GPIO10, GPIO9, GPIO8, GPIO9, GPIO8, GPIO7, GPIO6, GPIO15, GPIO14, GPIO13, GPIO12, GPIO11, GPIO10, GPIO2};

  void lock_setup(void) {
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_GPIOB);
    rcc_periph_clock_enable(RCC_GPIOC);
    for (uint8_t i = 0; i < 16; i ++) {
      gpio_mode_setup(ports[i], GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, ios[i]);
      gpio_clear(ports[i], ios[i]);
    }
  }

  void lock_off(uint8_t cabin) {
    gpio_set(ports[cabin], ios[cabin]);
    locking_off_cabins |= 1 << cabin;
  }

  void lock_on(uint8_t cabin) {
    gpio_clear(ports[cabin], ios[cabin]);
    locking_off_cabins &= ~(1 << cabin);
  }
#+end_src
** 红外检测
#+begin_src c :tangle /dev/shm/eggos/infrared.h
  #ifndef __INFRARED_H
  #define __INFRARED_H
  void infrared_setup(void);
  void infrared_eventloop(void);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/infrared.c
  #include <stdint.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/cm3/nvic.h>
  #include <libopencm3/stm32/exti.h>
  #include "defination.h"
  #include "infrared.h"
  #include "lock.h"
  #include "repl.h"
  #include "utility.h"
  #include "egg-fsm.h"
  #include "egg-infrared-fsm.h"

  static uint16_t fallen = 0;
  static uint32_t extis[16] = {EXTI0, EXTI1, EXTI2, EXTI3, EXTI4, EXTI5, EXTI6, EXTI7, EXTI8, EXTI9, EXTI10, EXTI11, EXTI12, EXTI13, EXTI14, EXTI15};
  static uint32_t ports[16] = {GPIOC, GPIOC, GPIOD, GPIOB, GPIOB, GPIOB, GPIOF, GPIOF, GPIOB, GPIOB, GPIOC, GPIOC, GPIOC, GPIOA, GPIOA, GPIOA};
  static uint32_t ios[16] = {GPIO0, GPIO1, GPIO2, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO8, GPIO9, GPIO10, GPIO11, GPIO12, GPIO13, GPIO14, GPIO15};
  static uint8_t exti_to_idx[16] = {14, 15, 8, 9, 10, 11, 1, 2, 12, 13, 5, 6, 7, 0, 3, 4};
  static uint8_t idx_to_exti[16] = {13, 6, 7, 14, 15, 10, 11, 12, 2, 3, 4, 5, 8, 9, 0, 1};
  static uint32_t infrared_states[16] = {EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE, EGG_INFRARED_READY_STATE};
  static uint32_t delay_timers[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  static uint32_t aftercase_timers[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  static uint16_t exti_value = 0XFF;

  void infrared_setup(void) {
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_GPIOB);
    rcc_periph_clock_enable(RCC_GPIOC);
    rcc_periph_clock_enable(RCC_GPIOD);
    rcc_periph_clock_enable(RCC_GPIOF);

    /* enable syscfg :], or else changing exti source from GPIOA is impossible */
    rcc_periph_clock_enable(RCC_SYSCFG_COMP);

    for (uint8_t i = 0; i < 16; i ++) {
      gpio_mode_setup(ports[i], GPIO_MODE_INPUT, GPIO_PUPD_PULLUP, ios[i]);
      exti_select_source(extis[i], ports[i]);
      exti_set_trigger(extis[i], EXTI_TRIGGER_FALLING);
      exti_reset_request(extis[i]);
      exti_enable_request(extis[i]);
    }

    nvic_enable_irq(NVIC_EXTI0_1_IRQ);
    nvic_enable_irq(NVIC_EXTI2_3_IRQ);
    nvic_enable_irq(NVIC_EXTI4_15_IRQ);
  }

  void infrared_eventloop(void) {
    uint8_t stepper = 0;
    while (fallen != 0) {
      if ((fallen & (1 << stepper)) != 0) {
        infrared_states[stepper] = egg_infrared_transform_state(infrared_states[stepper], EGG_INFRARED_EXTI_EVENT, &stepper);
        fallen &= ~(1 << stepper);
      }
      stepper ++;
    }
    for (uint8_t i = 0; i < 16; i ++) {
      if (infrared_states[i] == EGG_INFRARED_DELAY1_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, delay_timers[i], 19)) {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_TIMEOUT_EVENT, &i);
        }
      } else if (infrared_states[i] == EGG_INFRARED_DELAY2_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, delay_timers[i], 19)) {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_TIMEOUT_EVENT, &i);
        }
      } else if (infrared_states[i] == EGG_INFRARED_CHECKING1_STATE) {
        if ((exti_value & (1 << i)) == 0) {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_0_EVENT, &i);
        } else {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_1_EVENT, &i);
        }
      } else if (infrared_states[i] == EGG_INFRARED_CHECKING2_STATE) {
        if ((exti_value & (1 << i)) == 0) {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_0_EVENT, &i);
        } else {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_1_EVENT, &i);
        }
      } else if (infrared_states[i] == EGG_INFRARED_AFTERCASE_STATE) {
        if (UINT32_DIFF_GREATER_THAN(systick, aftercase_timers[i], 100)) {
          infrared_states[i] = egg_infrared_transform_state(infrared_states[i], EGG_INFRARED_TIMEOUT_EVENT, &i);
        }
      }
    }
  }

  void egg_infrared_do_action(enum EGG_INFRARED_ACTION action, void * data) {
    uint8_t cabin = * (uint8_t *) data;
    switch (action) {
    case EGG_INFRARED_START_DELAYER_ACTION:
      delay_timers[cabin] = systick;
      break;
    case EGG_INFRARED_CHECK_ACTION:
      if (gpio_get(ports[idx_to_exti[cabin]], ios[idx_to_exti[cabin]]) == 0) {
        exti_value &= ~(1 << cabin);
      } else {
        exti_value |= (1 << cabin);
      }
      break;
    case EGG_INFRARED_CLEAR_ACTION:
      exti_value |= 1 << cabin;
      break;
    case EGG_INFRARED_TRIGGER_ACTION:
      egg_states[cabin] = egg_transform_state(egg_states[cabin], EGG_INFRARED_TRIGGERED_EVENT, &cabin);
      aftercase_timers[cabin] = systick;
      if (debug == 1) {
        output_string("Infrared ");
        output_uint32(cabin + 1);
        output_string(" triggered\r\n");
      }
      break;
    }
  }

  void exti0_1_isr(void) {
    if (exti_get_flag_status(EXTI0)) {
      fallen |= (1 << exti_to_idx[0]);
      exti_reset_request(EXTI0);
    }
    if (exti_get_flag_status(EXTI1)) {
      fallen |= (1 << exti_to_idx[1]);
      exti_reset_request(EXTI1);
    }
  }

  void exti2_3_isr(void) {
    if (exti_get_flag_status(EXTI2)) {
      fallen |= (1 << exti_to_idx[2]);
      exti_reset_request(EXTI2);
    }
    if (exti_get_flag_status(EXTI3)) {
      fallen |= (1 << exti_to_idx[3]);
      exti_reset_request(EXTI3);
    }
  }

  void exti4_15_isr(void) {
    for (uint8_t i = 4; i < 16; i ++) {
      if (exti_get_flag_status(extis[i])) {
        fallen |= (1 << exti_to_idx[i]);
        exti_reset_request(extis[i]);
      }
    }
  }
#+end_src

注意：

1. EXTI 和 GPIO 是一一对应关系，EXTI0 只能由 PX0 触发。

2. 如果要 GPIOA 以外的 IO 口都能触发外部中断，必须使能 RCC_SYSCFG_COMP。

** 音频

#+begin_src c :tangle /dev/shm/eggos/speaker.h
  #ifndef _SPEAKER_H
  #define _SPEAKER_H
  #include <stdint.h>
  void speaker_setup(void);
  void speaker_eventloop(void);
  void speaker_play(uint16_t idx);
  void speaker_volume(uint8_t vol);
  #endif
#+end_src

#+begin_src c :tangle /dev/shm/eggos/speaker.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/stm32/timer.h>
  #include <libopencm3/cm3/nvic.h>
  #include "speaker.h"
  #include "defination.h"
  #include "utility.h"
  #include "ring.h"

  #define SPEAKER_TIM_RCC     RCC_TIM2
  #define SPEAKER_GPIO_RCC    RCC_GPIOA
  #define SPEAKER_TIM         TIM2
  #define SPEAKER_TIM_RST     RST_TIM2
  #define SPEAKER_PORT        GPIOA
  #define SPEAKER_IO          GPIO1
  #define SPEAKER_NVIC_IRQ    NVIC_TIM2_IRQ

  #define SPEAKER_BUFFER_BITSIZE 4

  struct ring_t speaker_tx;
  uint8_t speaker_tx_buffer[2 << (SPEAKER_BUFFER_BITSIZE - 1)];

  static volatile uint8_t count_to_send = 0; // count of bit to send
  static volatile uint16_t data = 0;

  static void speaker_write(uint8_t byte) {
    while (count_to_send != 0);
    data = ((((uint16_t)byte) << 1) | 0x0200);
    count_to_send = 10;
  }

  void speaker_setup(void) {

    ring_init(&speaker_tx, speaker_tx_buffer, SPEAKER_BUFFER_BITSIZE);

    rcc_periph_clock_enable(SPEAKER_TIM_RCC);
    rcc_periph_clock_enable(SPEAKER_GPIO_RCC);

    gpio_mode_setup(SPEAKER_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_PULLUP, SPEAKER_IO);
    gpio_set_output_options(SPEAKER_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SPEAKER_IO);

    /* Reset TIM2 peripheral to defaults. */
    rcc_periph_reset_pulse(SPEAKER_TIM_RST);

    timer_set_mode(SPEAKER_TIM, TIM_CR1_CKD_CK_INT, TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);

    timer_set_prescaler(SPEAKER_TIM, 499);

    timer_set_period(SPEAKER_TIM, 9);

    /* Enable TIM2 interrupt. */

    nvic_enable_irq(SPEAKER_NVIC_IRQ);
    timer_enable_update_event(SPEAKER_TIM); /* default at reset! */
    timer_enable_irq(SPEAKER_TIM, TIM_DIER_UIE);
    timer_enable_counter(SPEAKER_TIM);

    speaker_volume(15);
    speaker_volume(15);
  }

  void speaker_play(uint16_t idx) {
    uint8_t cmd[] = { 0x7E, 0x05, 0x41, 0x00, 0x00, 0x00, 0xEF };
    cmd[3] = (idx >> 8) & 0xFF;
    cmd[4] = (idx >> 0) & 0xFF;
    cmd[5] = cmd[1] ^ cmd[2] ^ cmd[3] ^ cmd[4];
    ring_write_array(&speaker_tx, cmd, 0, 7);
  }

  void speaker_volume(uint8_t vol) {
    uint8_t cmd[] = { 0x7E, 0x04, 0x31, 0x00, 0x00, 0xEF };
    cmd[3] = vol;
    cmd[4] = cmd[1] ^ cmd[2] ^ cmd[3];
    ring_write_array(&speaker_tx, cmd, 0, 6);
  }

  void speaker_eventloop(void) {
    if (ring_length(&speaker_tx) > 0) {
      uint8_t byte = 0;
      if (ring_read(&speaker_tx, &byte) != 0) {
        speaker_write(byte);
      }
    }
  }

  void tim2_isr(void) {
    if (TIM_SR(SPEAKER_TIM) & TIM_SR_UIF) {
      if (count_to_send == 0) {
        TIM_SR(SPEAKER_TIM) &= ~TIM_SR_UIF;
        return;
      }
      if ((data & 0x01) == 0) {
        gpio_clear(SPEAKER_PORT, SPEAKER_IO);
      } else {
        gpio_set(SPEAKER_PORT, SPEAKER_IO);
      }
      data >>= 1;
      count_to_send --;
      TIM_SR(SPEAKER_TIM) &= ~TIM_SR_UIF;
    }
  }
#+end_src
** GPIO
控制灯光
#+begin_src c :tangle /dev/shm/eggos/gpio.h
  #ifndef __GPIO_H
  #define __GPIO_H
  #include <stdint.h>

  void gpio_setup(void);
  void gpio_exclamation_mark(uint8_t gpio);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/gpio.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "gpio.h"

  static uint32_t ports[4] = {GPIOC, GPIOC, GPIOB, GPIOB};
  static uint32_t ios[4] = {GPIO4, GPIO5, GPIO0, GPIO1};

  void gpio_setup() {
    rcc_periph_clock_enable(RCC_GPIOB);
    rcc_periph_clock_enable(RCC_GPIOC);
    for (uint8_t i = 0; i < 4; i ++) {
      gpio_mode_setup(ports[i], GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, ios[i]);
    }
  }

  void gpio_exclamation_mark(uint8_t gpio) {
    for (uint8_t i = 0; i < 4; i ++) {
      if ((gpio & (1 << i)) != 0) {
        gpio_set(ports[i], ios[i]);
      } else {
        gpio_clear(ports[i], ios[i]);
      }
    }
  }
#+end_src
** LED
#+begin_src c :tangle /dev/shm/eggos/led.h
  #ifndef __LED_H
  #define __LED_H

  void led_setup(void);
  void led_on(void);
  void led_off(void);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/led.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "led.h"

  #define LED_RCC             RCC_GPIOF
  #define LED_PORT            GPIOF
  #define LED_IO              GPIO5

  void led_setup() {
    rcc_periph_clock_enable(LED_RCC);
    gpio_mode_setup(LED_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, LED_IO);
    led_off();
  }

  void led_on() {
    gpio_clear(LED_PORT, LED_IO);
  }

  void led_off() {
    gpio_set(LED_PORT, LED_IO);
  }
#+end_src
* REPL代码
REPL系统挂接到串口 1 上，允许通过命令对系统进行操作，比如查看参数，开
锁，关锁等。
** 基本框架
#+begin_src c :tangle /dev/shm/eggos/repl.h
  #ifndef __REPL_H
  #define __REPL_H

  #include "uart.h"
  #include "ring.h"

  #define _output_string_1(str, line) do {                                \
    uint32_t len##line = 0;                                               \
    while (str[len##line] != '\0') {                                      \
      len##line ++;                                                       \
    }                                                                     \
    uint8_t size##line = 0;                                               \
    if (len##line < 128) {                                                \
      size##line = 1;                                                     \
    } else if (len##line< 16384) {                                        \
      size##line = 2;                                                     \
    } else if (len##line< 2097152) {                                      \
      size##line = 3;                                                     \
    } else {                                                              \
      size##line = 4;                                                     \
    }                                                                     \
    if (len##line + size##line <= ring_available(&repl_tx)) {             \
      uint32_t reallen##line = len##line;                                 \
      while (len##line > 0) {                                             \
        ring_write(&repl_tx, len##line & 0x7F);                           \
        len##line >>= 7;                                                  \
      }                                                                   \
      ring_write_array(&repl_tx, (uint8_t *)str, 0, reallen##line);       \
    }                                                                     \
    } while (0)

  #define _output_string_0(str, line) _output_string_1(str, line)

  #define output_string(str) _output_string_0(str, __LINE__);

  #define _output_char_1(chr, line) do {                  \
      if (ring_available(&repl_tx) > 1) {                 \
        uint8_t buf##line[2] = { 0x01, chr };             \
        ring_write_array(&repl_tx, buf##line, 0, 2);      \
      }                                                   \
    } while(0)

  #define _output_char_0(chr, line) _output_char_1(chr, line)

  #define output_char(chr) _output_char_0(chr, __LINE__)

  #define _output_newline_1(line) do {                    \
      if (ring_available(&repl_tx) > 2) {                 \
        uint8_t buf##line[3] = { 0x02, '\r', '\n' };      \
        ring_write_array(&repl_tx, buf##line, 0, 3);      \
      }                                                   \
    } while (0)

  #define _output_newline_0(line) _output_newline_1(line)

  #define output_newline() _output_newline_0(__LINE__)

  #define _output_uint32_1(i, line) do {          \
      char buf##line[20];                         \
      bzero(buf##line, 20);                       \
      uint_to_string(i, buf##line);               \
      output_string(buf##line);                   \
    } while (0)

  #define _output_uint32_0(i, line) _output_uint32_1(i, line)

  #define output_uint32(i) _output_uint32_0(i, __LINE__)

  #define _output_byte_1(b, line) do {                            \
      for (uint8_t i##line = 0; i##line < 2; i##line ++) {        \
        switch ((b >> (8 - 4 * (i##line + 1))) & 0x0F) {          \
        case 0x00: output_char('0'); break;                       \
        case 0x01: output_char('1'); break;                       \
        case 0x02: output_char('2'); break;                       \
        case 0x03: output_char('3'); break;                       \
        case 0x04: output_char('4'); break;                       \
        case 0x05: output_char('5'); break;                       \
        case 0x06: output_char('6'); break;                       \
        case 0x07: output_char('7'); break;                       \
        case 0x08: output_char('8'); break;                       \
        case 0x09: output_char('9'); break;                       \
        case 0x0A: output_char('A'); break;                       \
        case 0x0B: output_char('B'); break;                       \
        case 0x0C: output_char('C'); break;                       \
        case 0x0D: output_char('D'); break;                       \
        case 0x0E: output_char('E'); break;                       \
        case 0x0F: output_char('F'); break;                       \
        }                                                         \
      }                                                           \
    } while (0)

  #define _output_byte_0(b, line) _output_byte_1(b, line)

  #define output_byte(b) _output_byte_0(b, __LINE__)

  extern struct uart_context_t repl_uart_context;

  extern struct ring_t repl_tx;
  extern struct ring_t repl_rx;
  extern uint8_t debug;

  void repl_setup(struct uart_context_t * ctx);
  void repl_eventloop(struct uart_context_t * ctx);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/repl.c
  #include <stdint.h>
  #include <stddef.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/usart.h>
  #include <libopencm3/cm3/nvic.h>
  #include "repl.h"
  #include "stack.h"
  #include "lock.h"
  #include "speaker.h"
  #include "gpio.h"
  #include "uart.h"
  #include "egg-repl-fsm.h"
  #include "egg-repl-lex-fsm.h"
  #include "utility.h"

  #define REPL_BUFFER_BITSIZE 10
  #define REPL_STACK_BUFFER_BITSIZE 6

  <<repl-lex-context>>
  uint8_t debug = 0;
  struct ring_t repl_tx, repl_rx;
  static struct egg_repl_lex_context_t repl_lex_context;
  static uint32_t repl_state, repl_lex_state;
  struct uart_context_t repl_uart_context;
  static struct stack_t repl_stack;

  static uint8_t repl_tx_buffer[2 << (REPL_BUFFER_BITSIZE - 1)];
  static uint8_t repl_rx_buffer[2 << (REPL_BUFFER_BITSIZE - 1)];
  static uint8_t repl_stack_buffer[2 << (REPL_STACK_BUFFER_BITSIZE - 1)];

  <<repl-lock-usage>>
  <<repl-debug-usage>>
  <<repl-play-usage>>
  <<repl-volume-usage>>
  <<repl-gpio-usage>>
  <<repl-help>>
  <<repl-lock-on>>
  <<repl-lock-off>>
  <<repl-debug-on>>
  <<repl-debug-off>>
  <<repl-play>>
  <<repl-volume>>
  <<repl-gpio>>
  <<egg-repl-fsm-action>>
  <<egg-repl-lex-fsm-action>>

  <<repl-setup>>
  <<repl-eventloop>>
#+end_src
** 配置
#+begin_src c :noweb-ref repl-setup
  void repl_setup(struct uart_context_t * ctx) {
    ring_init(&repl_tx, repl_tx_buffer, REPL_BUFFER_BITSIZE);
    ring_init(&repl_rx, repl_rx_buffer, REPL_BUFFER_BITSIZE);
    stack_init(&repl_stack, repl_stack_buffer, REPL_STACK_BUFFER_BITSIZE);
    ctx->tx = &repl_tx;
    ctx->rx = &repl_rx;
    ctx->baudrate = 115200;
    ctx->databits = 8;
    ctx->stopbits = 1;
    ctx->tx_interval = 1; // 10ms
    ctx->loop_interval = 9; // 10ms
    ctx->slot_enabled = 0;
    ctx->manual = 0;
    bzero(&repl_lex_context, sizeof(struct egg_repl_lex_context_t));
    repl_state = EGG_REPL_READY_STATE;
    repl_lex_state = EGG_REPL_LEX_READY_STATE;
  }
#+end_src
** 主循环
#+begin_src c :noweb-ref repl-eventloop
  void repl_eventloop(struct uart_context_t * ctx) {
    uint32_t rxlen = ring_length(ctx->rx);
    if (rxlen > 0) {
      for (uint32_t i = 0; i < rxlen; i ++) {
        uint8_t byte;
        ring_read(ctx->rx, &byte);
        repl_lex_context.byte = byte;
        if ('a' <= byte && byte <= 'z') {
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_CHAR_EVENT, &repl_lex_context);
        } else if ('A' <= byte && byte <= 'Z') {
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_CHAR_EVENT, &repl_lex_context);
        } else if ('0' <= byte && byte <= '9') {
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_DIGITIAL_EVENT, &repl_lex_context);
        } else if (byte == '\r') {
          output_char(byte);
          output_char('\n');
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_CR_EVENT, &repl_lex_context);
        } else if (byte == '\n') {
          output_char('\r');
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_CR_EVENT, &repl_lex_context);
        } else if (byte == '\t') {
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_TAB_EVENT, &repl_lex_context);
        } else if (byte == '\b') {
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_BS_EVENT, &repl_lex_context);
        } else if (byte == ' ') {
          output_char(byte);
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_SPACE_EVENT, &repl_lex_context);
        } else if (byte == 127) {
          output_char('\b');
          repl_lex_state = egg_repl_lex_transform_state(repl_lex_state, EGG_REPL_LEX_BS_EVENT, &repl_lex_context);
        }
      }
    }
  }
#+end_src
** 交互状态机
交互状态机用于解析从上位机发送来的数据。交互状态机的定义见
egg-repl-fsm.xlsx 文件。

#+begin_src c :noweb-ref egg-repl-fsm-action
  void egg_repl_do_action(enum EGG_REPL_ACTION action, void * data) {
    switch (action) {
    case EGG_REPL_HELP_ACTION:
      stack_clear(&repl_stack);
      repl_help();
      break;
    case EGG_REPL_LOCK_USAGE_ACTION:
      stack_clear(&repl_stack);
      repl_lock_usage();
      break;
    case EGG_REPL_NUMBER_ACTION:
      stack_push(&repl_stack, * (uint8_t *) data);
      break;
    case EGG_REPL_LOCK_OFF_ACTION: {
      uint8_t cabin = 0;
      stack_top(&repl_stack, &cabin);
      stack_pop(&repl_stack);
      repl_lock_off(cabin);
      break;
    }
    case EGG_REPL_LOCK_ON_ACTION: {
      uint8_t cabin = 0;
      stack_top(&repl_stack, &cabin);
      stack_pop(&repl_stack);
      repl_lock_on(cabin);
      break;
    }
    case EGG_REPL_DEBUG_USAGE_ACTION:
      stack_clear(&repl_stack);
      repl_debug_usage();
      break;
    case EGG_REPL_DEBUG_ON_ACTION:
      stack_clear(&repl_stack);
      repl_debug_on();
      break;
    case EGG_REPL_DEBUG_OFF_ACTION:
      stack_clear(&repl_stack);
      repl_debug_off();
      break;
    case EGG_REPL_PLAY_USAGE_ACTION:
      stack_clear(&repl_stack);
      repl_play_usage();
      break;
    case EGG_REPL_NUMBER16_ACTION:
      stack_push(&repl_stack, (* (uint8_t *) data) & 0xFF);
      stack_push(&repl_stack, ((* (uint16_t *) data) >> 8) & 0xFF);
      break;
    case EGG_REPL_PLAY_ACTION: {
      uint16_t audio = 0;
      uint8_t msb = 0, lsb = 0;
      stack_top(&repl_stack, &msb);
      stack_pop(&repl_stack);
      stack_top(&repl_stack, &lsb);
      stack_pop(&repl_stack);
      audio = (msb << 8) | lsb;
      repl_play(audio);
      break;
    }
    case EGG_REPL_VOLUME_USAGE_ACTION:
      stack_clear(&repl_stack);
      repl_volume_usage();
      break;
    case EGG_REPL_VOLUME_ACTION: {
      uint8_t vol = 0;
      stack_top(&repl_stack, &vol);
      stack_pop(&repl_stack);
      repl_volume(vol);
      break;
    }
    case EGG_REPL_GPIO_USAGE_ACTION:
      stack_clear(&repl_stack);
      repl_gpio_usage();
      break;
    case EGG_REPL_GPIO_ACTION: {
      uint8_t gpio = 0;
      stack_top(&repl_stack, &gpio);
      stack_pop(&repl_stack);
      repl_gpio(gpio);
      break;
    }
    }
  }
#+end_src
** 词法解析状态机
词法解析状态机见 egg-repl-lex-fsm.xlsx。
#+begin_src c :noweb-ref egg-repl-lex-fsm-action
  void egg_repl_lex_do_action(enum EGG_REPL_LEX_ACTION action, void * data) {
    struct egg_repl_lex_context_t * ctx = (struct egg_repl_lex_context_t *) data;
    switch (action) {
    case EGG_REPL_LEX_CR_ACTION:
      repl_state = egg_repl_transform_state(repl_state, EGG_REPL_CR_EVENT, NULL);
      break;
    case EGG_REPL_LEX_APPEND_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      break;
    case EGG_REPL_LEX_BACKSPACE_ACTION:
      if (ctx->ptr != 0) {
        ctx->ptr --;
      }
      break;
    case EGG_REPL_LEX_TOKEN_ACTION:
    case EGG_REPL_LEX_TOKEN_AND_CR_ACTION:
      if (ctx->ptr == 4 &&
          (ctx->buf[0] == 'H' || ctx->buf[0] == 'h') &&
          (ctx->buf[1] == 'E' || ctx->buf[1] == 'e') &&
          (ctx->buf[2] == 'L' || ctx->buf[2] == 'l') &&
          (ctx->buf[3] == 'P' || ctx->buf[3] == 'p')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_HELP_EVENT, NULL);
      } else if (ctx->ptr == 4 &&
          (ctx->buf[0] == 'L' || ctx->buf[0] == 'l') &&
          (ctx->buf[1] == 'O' || ctx->buf[1] == 'o') &&
          (ctx->buf[2] == 'C' || ctx->buf[2] == 'c') &&
          (ctx->buf[3] == 'K' || ctx->buf[3] == 'k')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_LOCK_EVENT, NULL);
      } else if (ctx->ptr == 5 &&
          (ctx->buf[0] == 'D' || ctx->buf[0] == 'd') &&
          (ctx->buf[1] == 'E' || ctx->buf[1] == 'e') &&
          (ctx->buf[2] == 'B' || ctx->buf[2] == 'b') &&
          (ctx->buf[3] == 'U' || ctx->buf[3] == 'u') &&
          (ctx->buf[4] == 'G' || ctx->buf[4] == 'g')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_DEBUG_EVENT, NULL);
      } else if (ctx->ptr == 2 &&
          (ctx->buf[0] == 'O' || ctx->buf[0] == 'o') &&
          (ctx->buf[1] == 'N' || ctx->buf[1] == 'n')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_ON_EVENT, NULL);
      } else if (ctx->ptr == 3 &&
          (ctx->buf[0] == 'O' || ctx->buf[0] == 'o') &&
          (ctx->buf[1] == 'F' || ctx->buf[1] == 'f') &&
          (ctx->buf[2] == 'F' || ctx->buf[2] == 'f')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_OFF_EVENT, NULL);
      } else if (ctx->ptr == 4 &&
          (ctx->buf[0] == 'P' || ctx->buf[0] == 'p') &&
          (ctx->buf[1] == 'L' || ctx->buf[1] == 'l') &&
          (ctx->buf[2] == 'A' || ctx->buf[2] == 'a') &&
          (ctx->buf[3] == 'Y' || ctx->buf[3] == 'y')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_PLAY_EVENT, NULL);
      } else if (ctx->ptr == 6 &&
          (ctx->buf[0] == 'V' || ctx->buf[0] == 'v') &&
          (ctx->buf[1] == 'O' || ctx->buf[1] == 'o') &&
          (ctx->buf[2] == 'L' || ctx->buf[2] == 'l') &&
          (ctx->buf[3] == 'U' || ctx->buf[3] == 'u') &&
          (ctx->buf[4] == 'M' || ctx->buf[4] == 'm') &&
          (ctx->buf[5] == 'E' || ctx->buf[5] == 'e')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_VOLUME_EVENT, NULL);
      } else if (ctx->ptr == 4 &&
          (ctx->buf[0] == 'G' || ctx->buf[0] == 'g') &&
          (ctx->buf[1] == 'P' || ctx->buf[1] == 'p') &&
          (ctx->buf[2] == 'I' || ctx->buf[2] == 'i') &&
          (ctx->buf[3] == 'O' || ctx->buf[3] == 'o')) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_GPIO_EVENT, NULL);
      } else {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_OTHERS_EVENT, NULL);
      }
      ctx->ptr = 0;
      if (action == EGG_REPL_LEX_TOKEN_AND_CR_ACTION) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_CR_EVENT, NULL);
      }
      break;
    case EGG_REPL_LEX_NUMBER_ACTION:
    case EGG_REPL_LEX_NUMBER_AND_CR_ACTION:
    case EGG_REPL_LEX_NUMBER_AND_APPEND_ACTION: {
      uint32_t num = string_to_uint((char *)ctx->buf, ctx->ptr);
      ctx->ptr = 0;
      repl_state = egg_repl_transform_state(repl_state, EGG_REPL_NUMBER_EVENT, &num);
      if (action == EGG_REPL_LEX_NUMBER_AND_CR_ACTION) {
        repl_state = egg_repl_transform_state(repl_state, EGG_REPL_CR_EVENT, NULL);
      } else if (action == EGG_REPL_LEX_NUMBER_AND_APPEND_ACTION) {
        ctx->buf[ctx->ptr ++] = ctx->byte;
      }
      break;
    }
    }
  }
#+end_src
** 词法解析上下文
交互上下文里要存放词法解析命令过程中用到的临时数据。
| name | type   |                                              |
|------+--------+----------------------------------------------|
| buf  | [byte] | 解析过程中使用的缓冲区, 命令行长度不超过 128 |
| ptr  | uint16 | 记录可用缓冲区的位置                         |
| byte | byte   | 解析的当前数据                               |

#+begin_src c :noweb-ref repl-lex-context
  struct egg_repl_lex_context_t {
    uint8_t buf[128];
    uint16_t ptr;
    uint8_t byte;
  };
#+end_src
** 交互命令
*** 帮助信息
**** help
#+begin_src c :noweb-ref repl-help
  static void repl_help(void) {
    repl_lock_usage();
    //repl_debug_usage();
    repl_play_usage();
    repl_volume_usage();
    repl_gpio_usage();
  }
#+end_src
**** lock usage
#+begin_src c :noweb-ref repl-lock-usage
  static void repl_lock_usage(void) {
    output_string("LOCK USAGE:\r\n");
    output_string("  LOCK ON cabin       关锁\r\n");
    output_string("    cabin             (1~16)\r\n");
    output_string("  LOCK OFF cabin      关锁\r\n");
    output_string("    cabin             (1~16)\r\n");
  }
#+end_src
**** debug usage
#+begin_src c :noweb-ref repl-debug-usage
  static void repl_debug_usage(void) {
    output_string("DEBUG USAGE:\r\n");
    output_string("  DEBUG ON            打开调试\r\n");
    output_string("  DEBUG OFF           关闭调试\r\n");
  }
#+end_src
**** play usage
#+begin_src c :noweb-ref repl-play-usage
  static void repl_play_usage(void) {
    output_string("PLAY USAGE:\r\n");
    output_string("  PLAY audio          播放音频\r\n");
    output_string("    audio             (1~65535)\r\n");
  }
#+end_src
**** volume usage
#+begin_src c :noweb-ref repl-volume-usage
  static void repl_volume_usage(void) {
    output_string("VOLUME USAGE:\r\n");
    output_string("  VOLUME vol          调节音量\r\n");
    output_string("    vol               (0~31)\r\n");
  }
#+end_src
**** gpio usage
#+begin_src c :noweb-ref repl-gpio-usage
  static void repl_gpio_usage(void) {
    output_string("GPIO USAGE:\r\n");
    output_string("  GPIO gpio           设置GPIO\r\n");
    output_string("    gpio              (0~15)\r\n");
  }
#+end_src
*** 开锁
REPL 上的 cabin 是从 1 开始计数的，需要调整为从 0 开始计数的。
#+begin_src c :noweb-ref repl-lock-off
  static void repl_lock_off(uint8_t cabin) {
    if (0 < cabin && cabin < 17) {
      lock_off(cabin - 1);
    } else {
      repl_lock_usage();
    }
  }
#+end_src
*** 关锁
REPL 上的 cabin 是从 1 开始计数的，需要调整为从 0 开始计数的。
#+begin_src c :noweb-ref repl-lock-on
  static void repl_lock_on(uint8_t cabin) {
    if (0 < cabin && cabin < 17) {
      lock_on(cabin - 1);
    } else {
      repl_lock_usage();
    }
  }
#+end_src
*** 调试开关
**** debug on
#+begin_src c :noweb-ref repl-debug-on
  static void repl_debug_on(void) {
    debug = 1;
  }
#+end_src
**** debug off
#+begin_src c :noweb-ref repl-debug-off
  static void repl_debug_off(void) {
    debug = 0;
  }
#+end_src
*** 音频
**** 播放
#+begin_src c :noweb-ref repl-play
  static void repl_play(uint16_t audio) {
    speaker_play(audio);
  }
#+end_src
**** 设置音量
#+begin_src c :noweb-ref repl-volume
  static void repl_volume(uint8_t volume) {
    if (volume > 31) {
      volume = 31;
    }
    speaker_volume(volume);
  }
#+end_src
*** GPIO
#+begin_src c :noweb-ref repl-gpio
  static void repl_gpio(uint8_t gpio) {
    gpio_exclamation_mark(gpio);
  }
#+end_src
* 辅助代码
** base64

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/base64.h
#ifndef _BASE64_H
#define _BASE64_H
#include <stdint.h>
uint32_t base64_encode_length(uint32_t len);
uint32_t base64_encode(const uint8_t *src, uint32_t len, uint8_t *dst, uint32_t dst_len);

uint32_t base64_decode_length(const uint8_t * buf, uint32_t len);
uint32_t base64_decode(const uint8_t * src, const uint32_t len, uint8_t * dst, const uint32_t dstlen);
#endif

#+end_src

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/base64.c
  #include <stdint.h>
  #include "base64.h"

  static const uint8_t base64_table[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  uint32_t base64_encode_length(uint32_t len) {
    uint32_t olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
    return olen;
  }

  uint32_t base64_encode(const uint8_t *src, uint32_t len, uint8_t *dst, uint32_t dst_len) {
    uint8_t *pos;
    const uint8_t *end;

    if (dst_len < len)
      return 0; /* integer overflow */

    end = src + len;
    pos = dst;
    while (end - src >= 3) {
      (*pos++) = base64_table[src[0] >> 2];
      (*pos++) = base64_table[((src[0] & 0x03) << 4) | (src[1] >> 4)];
      (*pos++) = base64_table[((src[1] & 0x0f) << 2) | (src[2] >> 6)];
      (*pos++) = base64_table[src[2] & 0x3f];
      src += 3;
    }

    if (end - src) {
      (*pos++) = base64_table[src[0] >> 2];
      if (end - src == 1) {
        (*pos++) = base64_table[(src[0] & 0x03) << 4];
        (*pos++) = '=';
      } else {
        (*pos++) = base64_table[((src[0] & 0x03) << 4) | (src[1] >> 4)];
        (*pos++) = base64_table[(src[1] & 0x0f) << 2];
      }
      (*pos++) = '=';
    }

    return pos - dst;
  }

  static const int b64index[256] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62, 63, 62, 62, 63, 52, 53, 54, 55,
    56, 57, 58, 59, 60, 61,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,
    7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  0,
    0,  0,  0, 63,  0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
  };

  uint32_t base64_decode_length(const uint8_t * buf, uint32_t len) {
    int pad = len > 0 && (len % 4 || buf[len - 1] == '=');
    uint32_t L = ((len + 3) / 4 - pad) * 4;
    uint32_t size = L / 4 * 3 + pad;
    if (len > L + 2 && buf[L + 2] != '=') size ++;
    return size;
  }

  uint32_t base64_decode(const uint8_t * src, const uint32_t len, uint8_t * dst, const uint32_t dstlen) {
    uint32_t ptr = 0;
    int pad = len > 0 && (len % 4 || src[len - 1] == '=');
    const uint32_t L = (dstlen - pad) / 3 * 4;

    for (uint32_t i = 0; i < L; i += 4) {
      int n = b64index[src[i]] << 18 | b64index[src[i + 1]] << 12 | b64index[src[i + 2]] << 6 | b64index[src[i + 3]];
      dst[ptr++] = n >> 16;
      dst[ptr++] = n >> 8 & 0xFF;
      dst[ptr++] = n & 0xFF;
    }
    if (pad) {
      int n = b64index[src[L]] << 18 | b64index[src[L + 1]] << 12;
      dst[ptr++] = n >> 16;

      if (len > L + 2 && src[L + 2] != '=') {
        n |= b64index[src[L + 2]] << 6;
        dst[ptr++] = n >> 8 & 0xFF;
      }
    }
    return ptr;
  }
#+end_src
** hash

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/hash.h
  #ifndef __HASH_H
  #define __HASH_H
  #include <stdint.h>

  uint8_t crc8(uint8_t * buf, uint32_t size);
  uint32_t adler32(uint8_t * buf, uint32_t size);
  #endif
#+end_src

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/hash.c
  #include "hash.h"

  #define CRC8_KEY 0x07

  uint8_t crc8(uint8_t * buf, uint32_t size) {
    uint8_t crc = 0;
    while (size-- != 0) {
      for (uint8_t i = 0x80; i != 0; i /= 2) {
        if ((crc & 0x80) != 0) {
          crc = crc << 1;
          crc ^= CRC8_KEY;
        } else {
          crc = crc << 1;
        }
        if (( * buf & i) != 0) {
          crc ^= CRC8_KEY;
        }
      }
      buf ++;
    }
    return crc;
  }

  uint32_t adler32(uint8_t * buf, uint32_t size) {
    uint32_t a = 1, b = 0;
    for (uint8_t i = 0; i < size; i ++) {
      uint8_t d = buf[i];
      a = (a + d) % 66521;
      b = (a + b) % 66521;
    }
    return (b << 16) | a;
  }
#+end_src
** ring
#+begin_src c :tangle /dev/shm/eggos/ring.h
  #ifndef __RING_H
  #define __RING_H
  #include <stdint.h>
  struct ring_t {
    uint8_t * data;
    uint32_t head;
    uint32_t tail;
    uint32_t mask;
  };

  #define ring_length(r) ((r)->tail - (r)->head)

  #define ring_is_empty(r) ((r)->head == (r)->tail)

  #define ring_empty(r) do {  \
      (r)->head = 0;          \
      (r)->tail = 0;          \
    } while(0)

  #define ring_available(r) ((r)->mask + 1 - ring_length(r))

  void ring_init(struct ring_t * ring, uint8_t * data, uint32_t bitsize);
  uint32_t ring_write(struct ring_t * ring, uint8_t data);
  uint32_t ring_write_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size);
  uint32_t ring_read(struct ring_t * ring, uint8_t * data);
  uint32_t ring_read_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/ring.c
  #include "ring.h"

  void ring_init(struct ring_t * ring, uint8_t * data, uint32_t bitsize) {
    ring->data = data;
    ring->head = 0;
    ring->tail = 0;
    ring->mask = (2 << (bitsize - 1)) - 1;
  }

  uint32_t ring_write(struct ring_t * ring, uint8_t data) {
    if (ring_available(ring) == 0) {
      return 0;
    }
    ring->data[ring->tail & ring->mask] = data;
    ring->tail += 1;
    return 1;
  }

  uint32_t ring_write_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size) {
    uint32_t cnt = 0;
    while (ring_available(ring) > 0 && cnt < size) {
      ring->data[ring->tail & ring->mask] = data[offset + cnt];
      ring->tail += 1;
      cnt ++;
    }
    return cnt;
  }

  uint32_t ring_read(struct ring_t * ring, uint8_t * data) {
    if (ring_is_empty(ring)) {
      return 0;
    }

    (* data) = ring->data[ring->head & ring->mask];
    ring->head += 1;
    return 1;
  }

  uint32_t ring_read_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size) {
    uint32_t cnt = 0;
    while (!ring_is_empty(ring) && cnt < size) {
      data[offset + cnt] = ring->data[ring->head & ring->mask];
      ring->head += 1;
      cnt ++;
    }
    return cnt;
  }
#+end_src
** stack
#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/stack.h
  #ifndef _STACK_H
  #define _STACK_H
  #include <stdint.h>

  struct stack_t {
    uint8_t * buffer;
    int top;
    uint32_t capacity;
  };

  void stack_init(struct stack_t * stack, uint8_t * buffer, uint32_t capacity);
  uint32_t stack_push(struct stack_t * stack, uint8_t e);
  uint32_t stack_pop(struct stack_t * stack);
  uint32_t stack_top(struct stack_t * stack, uint8_t * e);
  uint32_t stack_isempty(struct stack_t * stack);
  void stack_clear(struct stack_t * stack);
  #endif
#+end_src
#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/stack.c
  #include "stack.h"

  void stack_init(struct stack_t * stack, uint8_t * buffer, uint32_t capacity) {
    stack->buffer = buffer;
    stack->capacity = capacity;
    stack->top = -1;
  }

  uint32_t stack_push(struct stack_t * stack, uint8_t e) {
    if (stack->top < (int) stack->capacity) {
      stack->top ++ ;
      stack->buffer[stack->top] = e;
      return 1;
    } else {
      return 0;
    }
  }

  uint32_t stack_pop(struct stack_t * stack) {
    if (stack->top != -1) {
      stack->top --;
      return 1;
    } else {
      return 0;
    }
  }

  uint32_t stack_top(struct stack_t * stack, uint8_t * e) {
    if (stack->top != -1) {
      (* e) = stack->buffer[stack->top];
      return 1;
    } else {
      return 0;
    }
  }

  uint32_t stack_isempty(struct stack_t * stack) {
    return stack->top == -1;
  }

  void stack_clear(struct stack_t * stack) {
    stack->top = -1;
  }
#+end_src
** utility
#+begin_src c :tangle /dev/shm/eggos/utility.h
  #ifndef __UTILITY_H
  #define __UTILITY_H
  #include <stdint.h>

  void delay(uint32_t ms);
  uint8_t uint_to_string(uint32_t num, char buf[10]);
  uint8_t ulong_to_string(uint64_t num, char buf[20]);
  uint32_t string_to_uint(char * buf, uint32_t size);
  void bzero(void * base, uint32_t size);
  #endif

#+end_src
#+begin_src c :tangle /dev/shm/eggos/utility.c
  #include "utility.h"

  void delay(uint32_t ms) {
    ms *= 960; // 3360=168MHz, 1440=72MHz
    while (ms--) {
      __asm ("nop");
    }
  }

  uint8_t uint_to_string(uint32_t num, char buf[10]) {
    for (int i = 0; i < 10; i ++) {
      buf[i] = 0;
    }
    if (num == 0) {
      buf[0] = '0';
      return 1;
    }

    uint8_t ptr = 0;
    while (num != 0) {
      buf[ptr ++] = (num % 10) + 0x30;
      num /= 10;
    }
    for (uint32_t i = 0, len = ptr / 2; i < len; i ++) {
      char tmp = buf[i];
      buf[i] = buf[ptr - i - 1];
      buf[ptr - i - 1] = tmp;
    }
    return ptr;
  }

  uint8_t ulong_to_string(uint64_t num, char buf[20]) {
    for (int i = 0; i < 20; i ++) {
      buf[i] = 0;
    }
    if (num == 0) {
      buf[0] = '0';
      return 1;
    }

    uint8_t ptr = 0;
    while (num != 0) {
      buf[ptr ++] = (num % 10) + 0x30;
      num /= 10;
    }
    for (uint32_t i = 0, len = ptr / 2; i < len; i ++) {
      char tmp = buf[i];
      buf[i] = buf[ptr - i - 1];
      buf[ptr - i - 1] = tmp;
    }
    return ptr;
  }

  uint32_t string_to_uint(char * buf, uint32_t size) {
    uint32_t num = 0;
    for (uint32_t i = 0; i < size; i ++) {
      num *= 10;
      switch (buf[i]) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        num += buf[i] - 0x30;
      }
    }
    return num;
  }

  void bzero(void * base, uint32_t size) {
    uint32_t end = (uint32_t)base + size;
    while ((uint32_t)base != end) {
      (* (uint8_t *) base) = 0;
      base ++;
    }
  }
#+end_src
** 宏定义与全局变量
#+begin_src c :tangle /dev/shm/eggos/defination.h
  #ifndef __DEFINATION_H
  #define __DEFINATION_H

  #define UINT32_DIFF_LESS_THAN(a, b, delta) ((((a) < (b)) && ((a) + 0xFFFFFFFF - (b) < (delta))) || (((a) > (b)) && ((a) - (b) < (delta))))
  #define UINT32_DIFF_GREATER_THAN(a, b, delta) ((((a) < (b)) && ((a) + 0xFFFFFFFF - (b) > (delta))) || (((a) > (b)) && ((a) - (b) > (delta))))

  extern volatile uint32_t systick;
  extern uint32_t slot;
  extern uint32_t egg_states[16];
  extern uint32_t locking_timers[16];
  extern uint16_t locking_off_cabins;

  #endif
#+end_src
| name               | meaning               |
|--------------------+-----------------------|
| systick            | 系统时钟              |
| slot               | 上位机通讯窗口        |
| egg_states         | 蛋机核心状态          |
| locking_timers     | 解锁计时器            |
| locking_off_cabins | 开锁标志，驱动 LED 用 |
