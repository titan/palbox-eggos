#+TITLE: The core application for egg machine based on STM32F030
#+AUTHOR: Titan
#+EMAIL: howay.tan@fengchaohuzhu.com
#+DATE: <2018-07-11 Wed>
#+KEYWORDS: stm32, cortex m0, egg machine
#+OPTIONS: H:4 toc:t
#+STARTUP: indent

* 核心代码
** 基本框架
#+begin_src c :noweb yes :mkdirp yes :tangle /dev/shm/eggos/eggos.c
  #include <libopencm3/stm32/iwdg.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/cm3/nvic.h>
  #include <libopencm3/cm3/systick.h>
  #include <stddef.h>
  #include <stdint.h>
  #include "defination.h"
  #include "egg-fsm.h"
  #include "epigyny.h"
  #include "uart.h"
  #include "lock.h"
  #include "infrared.h"
  #include "speaker.h"
  #include "gpio.h"

  volatile uint32_t systick = 0;
  uint32_t egg_state = EGG_LOCKING_ON_STATE;
  uint32_t locking_timer = 0;

  <<sys-tick-handler>>

  static void setup(void) {
    <<setup-systick>>
    <<setup-epigyny>>
    <<setup-lock>>
    <<setup-infrared>>
    <<setup-speaker>>
    <<setup-gpio>>
    uart_setup();
  }

  <<egg-fsm-action>>

  int main(void) {
    setup();
    uint32_t loop_timer = systick;

    while (1) {
      // main loop
      infrared_eventloop();
      uart_eventloop();
      speaker_eventloop();
      <<main-loop>>
    }
    return 0;
  }
#+end_src
** 配置
*** 时钟
systick 设置为每 1 毫秒自增一次。
#+begin_src c :noweb-ref setup-systick
  /* 48MHz => 48000000 counts per second */
  systick_set_clocksource(STK_CSR_CLKSOURCE_AHB);

  /* 48,000,000/48,000 = 1000 overflows per second - every 1ms one interrupt */
  /* SysTick interrupt every N clock pulses: set reload to N-1 */
  systick_set_reload(47999);
  systick_interrupt_enable();
  systick_counter_enable();
#+end_src

#+begin_src c :noweb-ref sys-tick-handler
  void sys_tick_handler(void) {
    systick ++;
  }
#+end_src
*** 上位机通讯串口
上位机通讯挂在串口2上。

#+begin_src c :noweb-ref setup-epigyny
  uart2_context.setup = epigyny_setup;
  uart2_context.eventloop = epigyny_eventloop;

  uart_init(2, &uart2_context);
#+end_src

*** 锁控
#+begin_src c :noweb-ref setup-lock
  lock_setup();
#+end_src
*** 红外检测
#+begin_src c :noweb-ref setup-infrared
  infrared_setup();
#+end_src
*** 音频
#+begin_src c :noweb-ref setup-speaker
  speaker_setup();
#+end_src
*** GPIO
#+begin_src c :noweb-ref setup-gpio
  gpio_setup();
#+end_src
** 主循环
在初始化完成后，系统进入主循环，根据当前的状态和发生的事件，推动状态机
运行。
#+begin_src c :noweb-ref main-loop
  if (UINT32_DIFF_GREATER_THAN(systick, loop_timer, 999)) {
    loop_timer = systick;
    if (egg_state == EGG_LOCKING_ON_STATE) {
      if (UINT32_DIFF_GREATER_THAN(systick, locking_timer, 179999)) {
        egg_state = egg_transform_state(egg_state, EGG_3_MINUTES_TIMEOUT_EVENT, NULL);
      } else if (UINT32_DIFF_GREATER_THAN(systick, locking_timer, 119999)) {
        egg_state = egg_transform_state(egg_state, EGG_2_MINUTES_TIMEOUT_EVENT, NULL);
      } else if (UINT32_DIFF_GREATER_THAN(systick, locking_timer, 59999)) {
        egg_state = egg_transform_state(egg_state, EGG_1_MINUTE_TIMEOUT_EVENT, NULL);
      }
    }
  }
#+end_src

** 核心状态机
核心状态机的定义见 egg-fsm.xlsx 文件。
#+begin_src c :noweb-ref egg-fsm-action
  void egg_do_action(enum EGG_ACTION action, void * data) {
    (void) data;
    switch(action) {
    case EGG_PLAY_WELCOME_NEWLINE_LOCK_OFF_ACTION: break;
    case EGG_LOCK_ON_ACTION: break;
    case EGG_PLAY_GOODBYE_NEWLINE_LOCK_ON_ACTION: break;
    case EGG_PLAY_1M_TIMEOUT_ACTION: break;
    case EGG_PLAY_2M_TIMEOUT_ACTION: break;
    case EGG_PLAY_3M_TIMEOUT_NEWLINE_LOCK_ON_ACTION: break;
    }
  }
#+end_src
* 上位机处理
上位机处理部分执行并响应上位机下发的指令。
** 基本框架
#+begin_src c :noweb yes :mkdirp yes :tangle /dev/shm/eggos/epigyny.h
  #ifndef __EPIGYNY_H
  #define __EPIGYNY_H
  #include "uart.h"

  extern struct uart_context_t uart2_context;

  void epigyny_setup(struct uart_context_t * ctx);
  void epigyny_eventloop(struct uart_context_t * ctx);
  #endif
#+end_src
#+begin_src c :noweb yes :mkdirp yes :tangle /dev/shm/eggos/epigyny.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/usart.h>
  #include <libopencm3/cm3/nvic.h>
  #include <stddef.h>
  #include "defination.h"
  #include "epigyny.h"
  #include "egg_packet.h"
  #include "uart.h"
  #include "ring.h"
  #include "utility.h"
  #include "egg-fsm.h"
  #include "egg-proto-fsm.h"
  #include "speaker.h"
  #include "gpio.h"

  #define EPIGYNY_BUFFER_BITSIZE 8

  static struct ring_t epigyny_tx;
  static struct ring_t epigyny_rx;
  static uint8_t epigyny_tx_buffer[2 << (EPIGYNY_BUFFER_BITSIZE - 1)];
  static uint8_t epigyny_rx_buffer[2 << (EPIGYNY_BUFFER_BITSIZE - 1)];
  struct uart_context_t uart2_context;
  static uint32_t egg_proto_state;

  <<proto-context>>

  static struct egg_proto_context_t context;
  <<epigyny-setup>>
  <<epigyny-eventloop>>
  <<proto-callback>>
  <<egg-proto-fsm-action>>
#+end_src
** 配置
#+begin_src c :noweb-ref epigyny-setup
  void epigyny_setup(struct uart_context_t * ctx) {
    ring_init(&epigyny_tx, epigyny_tx_buffer, EPIGYNY_BUFFER_BITSIZE);
    ring_init(&epigyny_rx, epigyny_rx_buffer, EPIGYNY_BUFFER_BITSIZE);
    ctx->tx = &epigyny_tx;
    ctx->rx = &epigyny_rx;
    ctx->baudrate = 9600;
    ctx->databits = 8;
    ctx->stopbits = 1;
    ctx->tx_interval = 99; // 100ms
    ctx->loop_interval = 999; // 1s
    bzero(&context, sizeof(struct egg_proto_context_t));
    egg_proto_state = EGG_PROTO_READY_STATE;
  }
#+end_src
** 主循环
在主循环中，程序要检查 RX 中收到的数据。所有收到的数据要送到协议状态机
中进行处理。当协议状态机发现接收的是完成数据包时，调用回调函数对上位机
的命令进行处理。
#+begin_src c :noweb-ref epigyny-eventloop
  void epigyny_eventloop(struct uart_context_t * uartctx) {
    struct ring_t * rx = uartctx->rx;
    uint32_t rxlen = ring_length(rx);
    struct egg_proto_context_t * ctx = &context;
    if (rxlen > 0) {
      ctx->rx_timer = systick;
      for (uint32_t i = 0; i < rxlen; i ++) {
        if (ctx->countdown <= 0xFFFF) {
          ctx->countdown --;
        }
        uint8_t byte;
        ring_read(rx, &byte);
        ctx->byte = byte;
        if (byte == 0x00) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X00_EVENT, ctx);
        } else if (0x01 <= byte && byte <= 0x08) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X01_MINUS_0X08_EVENT, ctx);
        } else if (0x09 <= byte && byte <= 0x32) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X09_MINUS_0X32_EVENT, ctx);
        } else if (byte == 0x33) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X33_EVENT, ctx);
        } else if (0x34 <= byte && byte <= 0x3B) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X34_MINUS_0X3B_EVENT, ctx);
        } else if (byte == 0x3C) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X3C_EVENT, ctx);
        } else if (0x3D <= byte && byte <= 0xC2) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0X3D_MINUS_0XC2_EVENT, ctx);
        } else if (byte == 0xC3) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XC3_EVENT, ctx);
        } else if (0xC4 <= byte && byte <= 0xCB) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XC4_MINUS_0XCB_EVENT, ctx);
        } else if (byte == 0xCC) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XCC_EVENT, ctx);
        } else if (0xCD <= byte) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_0XCD_MINUS_0XFF_EVENT, ctx);
        }
        if (ctx->countdown == 0) {
          egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_COUNTDOWN_EQUALS_0_EVENT, ctx);
        }
      }
    }

    if (ctx->rx_timer != 0xFFFFFFFF && (UINT32_DIFF_GREATER_THAN(systick, ctx->rx_timer, 99))) { // 1s
      egg_proto_state = egg_proto_transform_state(egg_proto_state, EGG_PROTO_EOF_EVENT, ctx);
      ctx->rx_timer = 0xFFFFFFFF;
    }
  }
#+end_src
** 协议状态机
协议状态机用于解析从上位机发送来的数据。协议状态机的定义见
egg-proto-fsm.xlsx 文件。

#+begin_src c :noweb-ref egg-proto-fsm-action
  void egg_proto_do_action(enum EGG_PROTO_ACTION action, void * data) {
    struct egg_proto_context_t * ctx = (struct egg_proto_context_t *) data;
    switch (action) {
    case EGG_PROTO_APPEND_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      break;
    case EGG_PROTO_CLEAR_ACTION:
      bzero(ctx, sizeof(struct egg_proto_context_t));
      ctx->countdown = (uint32_t) 0xFFFFFFFF;
      break;
    case EGG_PROTO_APPEND_AND_SAVE_LEN0_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      ctx->len0 = ctx->byte;
      break;
    case EGG_PROTO_APPEND_AND_SAVE_LEN1_ACTION:
      ctx->buf[ctx->ptr ++] = ctx->byte;
      ctx->len1 = ctx->byte;
      ctx->countdown = ((ctx->len1 << 8) | ctx->len0) & 0xFFFF;
      break;
    case EGG_PROTO_CALLBACK_ACTION:
      epigyny_callback(ctx->buf, ctx->ptr);
      bzero(ctx, sizeof(struct egg_proto_context_t));
      break;
    }
  }
#+end_src

** 协议解析上下文
解析上下文里要存放在解析过程中用到的临时数据。
| name      | type   |                                                                                 |
|-----------+--------+---------------------------------------------------------------------------------|
| buf       | [byte] | 解析过程中使用的缓冲区                                                          |
| ptr       | uint16 | 记录可用缓冲区的位置                                                            |
| byte      | byte   | 解析的当前数据                                                                  |
| len0      | byte   | 包中 base64 内容的数据长度的低 8 位                                             |
| len1      | byte   | 包中 base64 内容的数据长度的高 8 位                                             |
| countdown | uint32 | 剩余应读取的 base64 内容的长度。为 0 时产生 countdown = 0 事件。                |
| rx_timer  | uint32 | 最后一次接收到数据的时间戳。当前事件与 rx_timer 差异大于 1000 时，产生 EOF 事件 |

#+begin_src c :noweb-ref proto-context
  struct egg_proto_context_t {
    uint8_t buf[512];
    uint16_t ptr;
    uint8_t byte;
    uint8_t len0;
    uint8_t len1;
    uint32_t countdown;
    uint32_t rx_timer;
  };
#+end_src
** 协议回调
#+begin_src c :noweb-ref proto-callback
  static void epigyny_callback(uint8_t * buf, uint32_t size) {
    uint32_t len = egg_packet_estimate_decode_size(buf, size);
    uint8_t tmp[len];
    bzero(tmp, len);
    struct egg_packet_t * packet = (struct egg_packet_t *) &tmp;

    struct egg_packet_t ackpacket;
    bzero(&ackpacket, sizeof(struct egg_packet_t));
    ackpacket.payload.sn = packet->payload.sn;
    ackpacket.payload.cmd = EGG_ACK;

    switch (egg_packet_decode(buf, size, packet)) {
    case EGG_LOCK_OFF: {
      egg_state = egg_transform_state(egg_state, EGG_LOCK_OFF_EVENT, NULL);
      ackpacket.payload.ack_type = EGG_LOCK_OFF;
      ackpacket.payload.cabin = packet->payload.cabin;
      break;
    }
    case EGG_LOCK_ON: {
      egg_state = egg_transform_state(egg_state, EGG_LOCK_ON_EVENT, NULL);
      ackpacket.payload.ack_type = EGG_LOCK_ON;
      ackpacket.payload.cabin = packet->payload.cabin;
      break;
    }
    case EGG_PLAY:
      speaker_play(packet->payload.audio);
      ackpacket.payload.ack_type = EGG_PLAY;
      ackpacket.payload.audio = packet->payload.audio;
      break;
    case EGG_GPIO:
      gpio(packet->payload.gpio);
      ackpacket.payload.ack_type = EGG_GPIO;
      ackpacket.payload.gpio = packet->payload.gpio;
      break;
    default:
      break;
    }

    uint32_t acklen = egg_packet_calculate_encode_size(&ackpacket);
    uint8_t size_of_len = 0;
    if (acklen < 128) {
      size_of_len = 1;
    } else if (acklen < 16384) {
      size_of_len = 2;
    } else if (acklen < 2097152) {
      size_of_len = 3;
    } else {
      size_of_len = 4;
    }
    if (ring_available(&epigyny_tx) >= acklen + size_of_len) {
      uint8_t ackbuf[acklen];
      bzero(ackbuf, acklen);
      uint32_t reallen = egg_packet_encode(&ackpacket, ackbuf, acklen);
      acklen = reallen;
      while (acklen > 0) {
        ring_write(&epigyny_tx, acklen & 0x7F);
        acklen = acklen >> 7;
      }
      ring_write_array(&epigyny_tx, ackbuf, 0, reallen);
    }

  }
#+end_src

* 驱动代码
** 串口
#+begin_src c :tangle /dev/shm/eggos/uart.h
  #ifndef __UART_H
  #define __UART_H
  #include <stdint.h>
  #include "ring.h"
  struct uart_context_t;
  typedef void (* uart_setup_fn)(struct uart_context_t * ctx);
  typedef void (* uart_eventloop_fn)(struct uart_context_t * ctx);
  struct uart_context_t {
    uint16_t baudrate;
    uint8_t databits, stopbits;
    struct ring_t * tx, * rx;
    uint32_t loop_timer;
    uint32_t loop_interval;
    uint32_t tx_timer;
    uint32_t tx_interval;
    uint32_t tx_to_send;
    //uint8_t uart;
    uart_setup_fn setup;
    uart_eventloop_fn eventloop;
  };


  void uart_init(uint8_t idx, struct uart_context_t * ctx);
  void uart_setup(void);
  void uart_start(void);
  void uart_eventloop(void);
  struct uart_context_t * uart_context(uint8_t idx);
  #endif
#+end_src

#+begin_src c :tangle /dev/shm/eggos/uart.c
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/usart.h>
  #include <libopencm3/cm3/nvic.h>
  #include <stddef.h>
  #include "defination.h"
  #include "uart.h"

  static int RCC_UART[2] = {
    RCC_USART1,
    RCC_USART2,
  };

  static int RCC_UART_GPIO[2] = {
    RCC_GPIOA,
    RCC_GPIOA,
  };

  static uint8_t NVIC_UART_IRQ[2] = {
    NVIC_USART1_IRQ,
    NVIC_USART2_IRQ,
  };

  static uint32_t TX_GPIO_PORT[2] = {
    GPIOA,
    GPIOA,
  };

  static uint32_t RX_GPIO_PORT[2] = {
    GPIOA,
    GPIOA,
  };

  static int TX_GPIO_IO[2] = {
    GPIO9,
    GPIO2,
  };

  static int RX_GPIO_IO[2] = {
    GPIO10,
    GPIO3,
  };

  static uint32_t UART[2] = {
    USART1,
    USART2,
  };

  struct uart_context_t * ctxs[2] = { NULL, NULL };

  void uart_init(uint8_t idx, struct uart_context_t * ctx) {
    ctxs[idx - 1] = ctx;
  }

  void uart_setup() {
    for (uint8_t i = 0; i < 2; i ++) {
      if (ctxs[i] != NULL) {
        ctxs[i]->setup(ctxs[i]);

        rcc_periph_clock_enable(RCC_UART[i]);
        rcc_periph_clock_enable(RCC_UART_GPIO[i]);

        nvic_enable_irq(NVIC_UART_IRQ[i]);

        gpio_mode_setup(TX_GPIO_PORT[i], GPIO_MODE_AF, GPIO_PUPD_NONE, TX_GPIO_IO[i]);
        gpio_mode_setup(RX_GPIO_PORT[i], GPIO_MODE_AF, GPIO_PUPD_NONE, RX_GPIO_IO[i]);

        gpio_set_af(TX_GPIO_PORT[i], GPIO_AF1, TX_GPIO_IO[i]);
        gpio_set_af(RX_GPIO_PORT[i], GPIO_AF1, RX_GPIO_IO[i]);

        /* Setup UART parameters. */
        usart_set_baudrate(UART[i], ctxs[i]->baudrate);
        usart_set_databits(UART[i], ctxs[i]->databits);
        usart_set_stopbits(UART[i], ctxs[i]->stopbits);
        usart_set_mode(UART[i], USART_MODE_TX_RX);
        usart_set_parity(UART[i], USART_PARITY_NONE);
        usart_set_flow_control(UART[i], USART_FLOWCONTROL_NONE);

        /* Enable LOCK Receive interrupt. */
        USART_CR1(UART[i]) |= USART_CR1_RXNEIE;

        /* Finally enable the USART. */
        usart_enable(UART[i]);
      }
    }
  }

  void uart_eventloop() {
    for (uint8_t i = 0; i < 2; i ++) {
      struct uart_context_t * ctx = ctxs[i];
      if (ctx != NULL) {
        if (UINT32_DIFF_GREATER_THAN(systick, ctx->loop_timer, ctx->loop_interval)) {
          ctx->loop_timer = systick;
        }
        if (UINT32_DIFF_GREATER_THAN(systick, ctx->tx_timer, ctx->tx_interval)) {
          ctx->tx_timer = systick;
          if (ctx->tx_to_send == 0) {
            if (ring_length(ctx->tx) > 1) {
              // saved length as varint type
              uint32_t len = 0;
              uint8_t byte = 0;
              uint8_t count = 0;
              ring_read(ctx->tx, &byte);
              while (byte > 127 && ring_length(ctx->tx) > 0) {
                ring_read(ctx->tx, &byte);
                len |= (byte & 0x7F) << (count * 7);
                count ++;
              }
              len |= (byte & 0x7F) << (count * 7);

              ctx->tx_to_send = len;
              USART_CR1(UART[i]) |= USART_CR1_TXEIE;
            }
          } else {
            USART_CR1(UART[i]) |= USART_CR1_TXEIE;
          }
        }
        ctx->eventloop(ctx);
      }
    }
  }

  struct uart_context_t * uart_context(uint8_t idx) {
    return ctxs[idx - 1];
  }

  static void uart_isr(uint8_t idx) {

    uint8_t data = 0;
    uint32_t result = 0;

    struct uart_context_t * ctx = ctxs[idx];
    if (ctx == NULL) return;

    /* Check if we were called because of RXNE. */
    if (((USART_CR1(UART[idx]) & USART_CR1_RXNEIE) != 0) && ((USART_ISR(UART[idx]) & USART_ISR_RXNE) != 0)) {

      /* Retrieve the data from the peripheral. */
      data = usart_recv(UART[idx]);
      ring_write(ctx->rx, data);
      if (ring_available(ctx->rx) == 0) {
        /* Disable the RXNEIE interrupt */
        USART_CR1(UART[idx]) &= ~USART_CR1_RXNEIE;
      }
    }

    /* Check if we were called because of TXE. */
    if (((USART_CR1(UART[idx]) & USART_CR1_TXEIE) != 0) && ((USART_ISR(UART[idx]) & USART_ISR_TXE) != 0)) {
      if (ctx->tx_to_send == 0) {
        USART_CR1(UART[idx]) &= ~USART_CR1_TXEIE;
        return;
      }

      result = ring_read(ctx->tx, &data);

      if (result == 0) {
        /* Disable the TXE interrupt, it's no longer needed. */
        USART_CR1(UART[idx]) &= ~USART_CR1_TXEIE;
      } else {
        /* Put data into the transmit register. */
        usart_send(UART[idx], data);
        ctx->tx_to_send --;
      }
    }
  }

  void usart1_isr(void) {
    uart_isr(1 - 1);
  }

  void usart2_isr(void) {
    uart_isr(2 - 1);
  }
#+end_src
** 锁控
#+begin_src c :tangle /dev/shm/eggos/lock.h
  #ifndef __LOCK_H
  #define __LOCK_H
  #include <stdint.h>

  void lock_setup(void);
  void lock_off(uint8_t box);
  void lock_on(uint8_t box);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/lock.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "lock.h"

  static uint32_t rccs[16] = {RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA, RCC_GPIOA};
  static uint32_t ports[16] = {GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA, GPIOA};
  static uint32_t ios[16] = {GPIO0, GPIO1, GPIO2, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO8, GPIO9, GPIO10, GPIO11, GPIO12, GPIO13, GPIO14, GPIO15};

  void lock_setup(void) {
    for (uint8_t i = 0; i < 16; i ++) {
      rcc_periph_clock_enable(rccs[i]);
      gpio_mode_setup(ports[i], GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, ios[i]);
    }
  }

  void lock_off(uint8_t box) {
    gpio_set(ports[box - 1], ios[box - 1]);
  }

  void lock_on(uint8_t box) {
    gpio_clear(ports[box - 1], ios[box - 1]);
  }
#+end_src
** 红外检测
#+begin_src c :tangle /dev/shm/eggos/infrared.h
  #ifndef __INFRARED_H
  #define __INFRARED_H
  void infrared_setup(void);
  void infrared_eventloop(void);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/infrared.c
  #include <stdint.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/cm3/nvic.h>
  #include <libopencm3/stm32/exti.h>
  #include "infrared.h"
  #include "lock.h"

  static uint16_t fallen = 0;
  static uint32_t extis[16] = {EXTI0, EXTI1, EXTI2, EXTI3, EXTI4, EXTI5, EXTI6, EXTI7, EXTI8, EXTI9, EXTI10, EXTI11, EXTI12, EXTI13, EXTI14, EXTI15};
  static uint32_t rccs[16] = {RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB, RCC_GPIOB};
  static uint32_t ports[16] = {GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB, GPIOB};
  static uint32_t ios[16] = {GPIO0, GPIO1, GPIO2, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO8, GPIO9, GPIO10, GPIO11, GPIO12, GPIO13, GPIO14, GPIO15};

  void infrared_setup(void) {
    for (uint8_t i = 0; i < 16; i ++) {
      rcc_periph_clock_enable(rccs[i]);
      gpio_mode_setup(ports[i], GPIO_MODE_INPUT, GPIO_PUPD_PULLUP, ios[i]);
      exti_select_source(extis[i], ports[i]);
      exti_set_trigger(extis[i], EXTI_TRIGGER_FALLING);
      exti_reset_request(extis[i]);
      exti_enable_request(extis[i]);
    }
    nvic_enable_irq(NVIC_EXTI0_1_IRQ);
    nvic_enable_irq(NVIC_EXTI2_3_IRQ);
    nvic_enable_irq(NVIC_EXTI4_15_IRQ);
  }

  void infrared_eventloop(void) {
    uint8_t stepper = 0;
    while (fallen != 0) {
      if ((fallen & (1 << stepper)) != 0) {
        lock_on(stepper + 1);
        fallen &= ~(1 << stepper);
      }
      stepper ++;
    }
  }

  void exti0_1_isr(void) {
    if (exti_get_flag_status(EXTI0)) {
      fallen |= (1 << 0);
      exti_reset_request(EXTI0);
    }
    if (exti_get_flag_status(EXTI1)) {
      fallen |= (1 << 1);
      exti_reset_request(EXTI1);
    }
  }

  void exti2_3_isr(void) {
    if (exti_get_flag_status(EXTI2)) {
      fallen |= (1 << 2);
      exti_reset_request(EXTI2);
    }
    if (exti_get_flag_status(EXTI3)) {
      fallen |= (1 << 3);
      exti_reset_request(EXTI3);
    }
  }

  void exti4_15_isr(void) {
    for (uint8_t i = 4; i < 16; i ++) {
      fallen |= (1 << i);
      exti_reset_request(extis[i]);
    }
  }
#+end_src
** 音频

#+begin_src c :tangle /dev/shm/eggos/speaker.h
  #ifndef _SPEAKER_H
  #define _SPEAKER_H
  #include <stdint.h>
  void speaker_setup(void);
  void speaker_eventloop(void);
  void speaker_play(uint16_t idx);
  void speaker_volume_up(void);
  void speaker_volume_down(void);
  void speaker_volume(uint8_t vol);
  #endif
#+end_src

#+begin_src c :tangle /dev/shm/eggos/speaker.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include <libopencm3/stm32/timer.h>
  #include <libopencm3/cm3/nvic.h>
  #include "speaker.h"
  #include "defination.h"
  #include "utility.h"
  #include "ring.h"

  #define SPEAKER_TIM_RCC     RCC_TIM2
  #define SPEAKER_GPIO_RCC    RCC_GPIOB
  #define SPEAKER_TIM         TIM2
  #define SPEAKER_TIM_RST     RST_TIM2
  #define SPEAKER_PORT        GPIOB
  #define SPEAKER_IO          GPIO1
  #define SPEAKER_NVIC_IRQ    NVIC_TIM2_IRQ

  #define SPEAKER_BUFFER_BITSIZE 4

  struct ring_t speaker_tx;
  uint8_t speaker_tx_buffer[2 << (SPEAKER_BUFFER_BITSIZE - 1)];

  static volatile uint8_t count_to_send = 0; // count of bit to send
  static volatile uint16_t data = 0;

  static void speaker_write(uint8_t byte) {
    while (count_to_send != 0);
    data = ((((uint16_t)byte) << 1) | 0x0200);
    count_to_send = 10;
  }

  void speaker_setup(void) {

    ring_init(&speaker_tx, speaker_tx_buffer, SPEAKER_BUFFER_BITSIZE);

    rcc_periph_clock_enable(SPEAKER_TIM_RCC);
    rcc_periph_clock_enable(SPEAKER_GPIO_RCC);

    gpio_mode_setup(SPEAKER_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_PULLUP, SPEAKER_IO);
    gpio_set_output_options(SPEAKER_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SPEAKER_IO);

    /* Reset TIM2 peripheral to defaults. */
    rcc_periph_reset_pulse(SPEAKER_TIM_RST);

    timer_set_mode(SPEAKER_TIM, TIM_CR1_CKD_CK_INT, TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);

    timer_set_prescaler(SPEAKER_TIM, 499);

    timer_set_period(SPEAKER_TIM, 9);

    /* Enable TIM2 interrupt. */

    nvic_enable_irq(SPEAKER_NVIC_IRQ);
    timer_enable_update_event(SPEAKER_TIM); /* default at reset! */
    timer_enable_irq(SPEAKER_TIM, TIM_DIER_UIE);
    timer_enable_counter(SPEAKER_TIM);

    speaker_play(1); // make speaker work immediately
  }

  void speaker_play(uint16_t idx) {
    uint8_t cmd[] = { 0x7E, 0x05, 0x41, 0x00, 0x00, 0x00, 0xEF };
    cmd[3] = (idx >> 8) & 0xFF;
    cmd[4] = (idx >> 0) & 0xFF;
    cmd[5] = cmd[1] ^ cmd[2] ^ cmd[3] ^ cmd[4];
    ring_write_array(&speaker_tx, cmd, 0, 7);
  }

  void speaker_volume_up() {
    uint8_t cmd[] = { 0x7E, 0x03, 0x15, 0x16, 0xEF };
    ring_write_array(&speaker_tx, cmd, 0, 5);
  }

  void speaker_volume_down() {
    uint8_t cmd[] = { 0x7E, 0x03, 0x16, 0x15, 0xEF };
    ring_write_array(&speaker_tx, cmd, 0, 5);
  }

  void speaker_volume(uint8_t vol) {
    uint8_t cmd[] = { 0x7E, 0x04, 0x31, 0x00, 0x00, 0xEF };
    cmd[3] = vol;
    cmd[4] = cmd[1] ^ cmd[2] ^ cmd[3];
    ring_write_array(&speaker_tx, cmd, 0, 6);
  }

  void speaker_eventloop(void) {
    if (ring_length(&speaker_tx) > 0) {
      uint8_t byte = 0;
      if (ring_read(&speaker_tx, &byte) != 0) {
        speaker_write(byte);
      }
    }
  }

  void tim2_isr(void) {
    if (TIM_SR(SPEAKER_TIM) & TIM_SR_UIF) {
      if (count_to_send == 0) {
        TIM_SR(SPEAKER_TIM) &= ~TIM_SR_UIF;
        return;
      }
      if ((data & 0x01) == 0) {
        gpio_clear(SPEAKER_PORT, SPEAKER_IO);
      } else {
        gpio_set(SPEAKER_PORT, SPEAKER_IO);
      }
      data >>= 1;
      count_to_send --;
      TIM_SR(SPEAKER_TIM) &= ~TIM_SR_UIF;
    }
  }
#+end_src
** GPIO
控制灯光
#+begin_src c :tangle /dev/shm/eggos/gpio.h
  #ifndef __GPIO_H
  #define __GPIO_H
  #include <stdint.h>

  void gpio_setup(void);
  void gpio(uint8_t gpio);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/gpio.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "gpio.h"

  static uint32_t rccs[4] = {RCC_GPIOC, RCC_GPIOC, RCC_GPIOC, RCC_GPIOC};
  static uint32_t ports[4] = {GPIOC, GPIOC, GPIOC, GPIOC};
  static uint32_t ios[4] = {GPIO0, GPIO1, GPIO2, GPIO3};

  void gpio_setup() {
    for (uint8_t i = 0; i < 4; i ++) {
      rcc_periph_clock_enable(rccs[i]);
      gpio_mode_setup(ports[i], GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, ios[i]);
    }
  }

  void gpio(uint8_t gpio) {
    for (uint8_t i = 0; i < 4; i ++) {
      if ((gpio & (1 << i)) != 0) {
        gpio_set(ports[i], ios[i]);
      } else {
        gpio_clear(ports[i], ios[i]);
      }
    }
  }
#+end_src
* 辅助代码
** base64

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/base64.h
#ifndef _BASE64_H
#define _BASE64_H
#include <stdint.h>
uint32_t base64_encode_length(uint32_t len);
uint32_t base64_encode(const uint8_t *src, uint32_t len, uint8_t *dst, uint32_t dst_len);

uint32_t base64_decode_length(const uint8_t * buf, uint32_t len);
uint32_t base64_decode(const uint8_t * src, const uint32_t len, uint8_t * dst, const uint32_t dstlen);
#endif

#+end_src

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/base64.c
  #include <stdint.h>
  #include "base64.h"

  static const uint8_t base64_table[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  uint32_t base64_encode_length(uint32_t len) {
    uint32_t olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
    return olen;
  }

  uint32_t base64_encode(const uint8_t *src, uint32_t len, uint8_t *dst, uint32_t dst_len) {
    uint8_t *pos;
    const uint8_t *end;

    if (dst_len < len)
      return 0; /* integer overflow */

    end = src + len;
    pos = dst;
    while (end - src >= 3) {
      (*pos++) = base64_table[src[0] >> 2];
      (*pos++) = base64_table[((src[0] & 0x03) << 4) | (src[1] >> 4)];
      (*pos++) = base64_table[((src[1] & 0x0f) << 2) | (src[2] >> 6)];
      (*pos++) = base64_table[src[2] & 0x3f];
      src += 3;
    }

    if (end - src) {
      (*pos++) = base64_table[src[0] >> 2];
      if (end - src == 1) {
        (*pos++) = base64_table[(src[0] & 0x03) << 4];
        (*pos++) = '=';
      } else {
        (*pos++) = base64_table[((src[0] & 0x03) << 4) | (src[1] >> 4)];
        (*pos++) = base64_table[(src[1] & 0x0f) << 2];
      }
      (*pos++) = '=';
    }

    return pos - dst;
  }

  static const int b64index[256] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62, 63, 62, 62, 63, 52, 53, 54, 55,
    56, 57, 58, 59, 60, 61,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,
    7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  0,
    0,  0,  0, 63,  0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
  };

  uint32_t base64_decode_length(const uint8_t * buf, uint32_t len) {
    int pad = len > 0 && (len % 4 || buf[len - 1] == '=');
    uint32_t L = ((len + 3) / 4 - pad) * 4;
    uint32_t size = L / 4 * 3 + pad;
    if (len > L + 2 && buf[L + 2] != '=') size ++;
    return size;
  }

  uint32_t base64_decode(const uint8_t * src, const uint32_t len, uint8_t * dst, const uint32_t dstlen) {
    uint32_t ptr = 0;
    int pad = len > 0 && (len % 4 || src[len - 1] == '=');
    const uint32_t L = (dstlen - pad) / 3 * 4;

    for (uint32_t i = 0; i < L; i += 4) {
      int n = b64index[src[i]] << 18 | b64index[src[i + 1]] << 12 | b64index[src[i + 2]] << 6 | b64index[src[i + 3]];
      dst[ptr++] = n >> 16;
      dst[ptr++] = n >> 8 & 0xFF;
      dst[ptr++] = n & 0xFF;
    }
    if (pad) {
      int n = b64index[src[L]] << 18 | b64index[src[L + 1]] << 12;
      dst[ptr++] = n >> 16;

      if (len > L + 2 && src[L + 2] != '=') {
        n |= b64index[src[L + 2]] << 6;
        dst[ptr++] = n >> 8 & 0xFF;
      }
    }
    return ptr;
  }
#+end_src
** hash

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/hash.h
  #ifndef __HASH_H
  #define __HASH_H
  #include <stdint.h>

  uint8_t crc8(uint8_t * buf, uint32_t size);
  uint32_t adler32(uint8_t * buf, uint32_t size);
  #endif
#+end_src

#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/hash.c
  #include "hash.h"

  #define CRC8_KEY 0x07

  uint8_t crc8(uint8_t * buf, uint32_t size) {
    uint8_t crc = 0;
    while (size-- != 0) {
      for (uint8_t i = 0x80; i != 0; i /= 2) {
        if ((crc & 0x80) != 0) {
          crc = crc << 1;
          crc ^= CRC8_KEY;
        } else {
          crc = crc << 1;
        }
        if (( * buf & i) != 0) {
          crc ^= CRC8_KEY;
        }
      }
      buf ++;
    }
    return crc;
  }

  uint32_t adler32(uint8_t * buf, uint32_t size) {
    uint32_t a = 1, b = 0;
    for (uint8_t i = 0; i < size; i ++) {
      uint8_t d = buf[i];
      a = (a + d) % 66521;
      b = (a + b) % 66521;
    }
    return (b << 16) | a;
  }
#+end_src
** ring
#+begin_src c :tangle /dev/shm/eggos/ring.h
  #ifndef __RING_H
  #define __RING_H
  #include <stdint.h>
  struct ring_t {
    uint8_t * data;
    uint32_t head;
    uint32_t tail;
    uint32_t mask;
  };

  #define ring_length(r) ((r)->tail - (r)->head)

  #define ring_is_empty(r) ((r)->head == (r)->tail)

  #define ring_empty(r) do {  \
      (r)->head = 0;          \
      (r)->tail = 0;          \
    } while(0)

  #define ring_available(r) ((r)->mask + 1 - ring_length(r))

  void ring_init(struct ring_t * ring, uint8_t * data, uint32_t bitsize);
  uint32_t ring_write(struct ring_t * ring, uint8_t data);
  uint32_t ring_write_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size);
  uint32_t ring_read(struct ring_t * ring, uint8_t * data);
  uint32_t ring_read_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/eggos/ring.c
  #include "ring.h"

  void ring_init(struct ring_t * ring, uint8_t * data, uint32_t bitsize) {
    ring->data = data;
    ring->head = 0;
    ring->tail = 0;
    ring->mask = (2 << (bitsize - 1)) - 1;
  }

  uint32_t ring_write(struct ring_t * ring, uint8_t data) {
    if (ring_available(ring) == 0) {
      return 0;
    }
    ring->data[ring->tail & ring->mask] = data;
    ring->tail += 1;
    return 1;
  }

  uint32_t ring_write_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size) {
    uint32_t cnt = 0;
    while (ring_available(ring) > 0 && cnt < size) {
      ring->data[ring->tail & ring->mask] = data[offset + cnt];
      ring->tail += 1;
      cnt ++;
    }
    return cnt;
  }

  uint32_t ring_read(struct ring_t * ring, uint8_t * data) {
    if (ring_is_empty(ring)) {
      return 0;
    }

    (* data) = ring->data[ring->head & ring->mask];
    ring->head += 1;
    return 1;
  }

  uint32_t ring_read_array(struct ring_t * ring, uint8_t * data, uint32_t offset, uint32_t size) {
    uint32_t cnt = 0;
    while (!ring_is_empty(ring) && cnt < size) {
      data[offset + cnt] = ring->data[ring->head & ring->mask];
      ring->head += 1;
      cnt ++;
    }
    return cnt;
  }
#+end_src
** stack
#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/stack.h
  #ifndef _STACK_H
  #define _STACK_H
  #include <stdint.h>

  struct stack_t {
    uint8_t * buffer;
    int top;
    uint32_t capacity;
  };

  void stack_init(struct stack_t * stack, uint8_t * buffer, uint32_t capacity);
  uint32_t stack_push(struct stack_t * stack, uint8_t e);
  uint32_t stack_pop(struct stack_t * stack);
  uint32_t stack_top(struct stack_t * stack, uint8_t * e);
  uint32_t stack_isempty(struct stack_t * stack);
  void stack_clear(struct stack_t * stack);
  #endif
#+end_src
#+begin_src c :mkdirp yes :tangle /dev/shm/eggos/stack.c
  #include "stack.h"

  void stack_init(struct stack_t * stack, uint8_t * buffer, uint32_t capacity) {
    stack->buffer = buffer;
    stack->capacity = capacity;
    stack->top = -1;
  }

  uint32_t stack_push(struct stack_t * stack, uint8_t e) {
    if (stack->top < (int) stack->capacity) {
      stack->top ++ ;
      stack->buffer[stack->top] = e;
      return 1;
    } else {
      return 0;
    }
  }

  uint32_t stack_pop(struct stack_t * stack) {
    if (stack->top != -1) {
      stack->top --;
      return 1;
    } else {
      return 0;
    }
  }

  uint32_t stack_top(struct stack_t * stack, uint8_t * e) {
    if (stack->top != -1) {
      (* e) = stack->buffer[stack->top];
      return 1;
    } else {
      return 0;
    }
  }

  uint32_t stack_isempty(struct stack_t * stack) {
    return stack->top == -1;
  }

  void stack_clear(struct stack_t * stack) {
    stack->top = -1;
  }
#+end_src
** utility
#+begin_src c :tangle /dev/shm/eggos/utility.h
  #ifndef __UTILITY_H
  #define __UTILITY_H
  #include <stdint.h>

  void delay(uint32_t ms);
  uint8_t uint_to_string(uint32_t num, char buf[10]);
  uint8_t ulong_to_string(uint64_t num, char buf[20]);
  uint32_t string_to_uint(char * buf, uint32_t size);
  void bzero(void * base, uint32_t size);
  #endif

#+end_src
#+begin_src c :tangle /dev/shm/eggos/utility.c
  #include "utility.h"

  void delay(uint32_t ms) {
    ms *= 960; // 3360=168MHz, 1440=72MHz
    while (ms--) {
      __asm ("nop");
    }
  }

  uint8_t uint_to_string(uint32_t num, char buf[10]) {
    for (int i = 0; i < 10; i ++) {
      buf[i] = 0;
    }
    if (num == 0) {
      buf[0] = '0';
      return 1;
    }

    uint8_t ptr = 0;
    while (num != 0) {
      buf[ptr ++] = (num % 10) + 0x30;
      num /= 10;
    }
    for (uint32_t i = 0, len = ptr / 2; i < len; i ++) {
      char tmp = buf[i];
      buf[i] = buf[ptr - i - 1];
      buf[ptr - i - 1] = tmp;
    }
    return ptr;
  }

  uint8_t ulong_to_string(uint64_t num, char buf[20]) {
    for (int i = 0; i < 20; i ++) {
      buf[i] = 0;
    }
    if (num == 0) {
      buf[0] = '0';
      return 1;
    }

    uint8_t ptr = 0;
    while (num != 0) {
      buf[ptr ++] = (num % 10) + 0x30;
      num /= 10;
    }
    for (uint32_t i = 0, len = ptr / 2; i < len; i ++) {
      char tmp = buf[i];
      buf[i] = buf[ptr - i - 1];
      buf[ptr - i - 1] = tmp;
    }
    return ptr;
  }

  uint32_t string_to_uint(char * buf, uint32_t size) {
    uint32_t num = 0;
    for (uint32_t i = 0; i < size; i ++) {
      num *= 10;
      switch (buf[i]) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        num += buf[i] - 0x30;
      }
    }
    return num;
  }

  void bzero(void * base, uint32_t size) {
    uint32_t end = (uint32_t)base + size;
    while ((uint32_t)base != end) {
      (* (uint8_t *) base) = 0;
      base ++;
    }
  }
#+end_src
** 宏定义
#+begin_src c :tangle /dev/shm/eggos/defination.h
  #ifndef __DEFINATION_H
  #define __DEFINATION_H

  #define UINT32_DIFF_LESS_THAN(a, b, delta) ((((a) < (b)) && ((a) + 0xFFFFFFFF - (b) < (delta))) || (((a) > (b)) && ((a) - (b) < (delta))))
  #define UINT32_DIFF_GREATER_THAN(a, b, delta) ((((a) < (b)) && ((a) + 0xFFFFFFFF - (b) > (delta))) || (((a) > (b)) && ((a) - (b) > (delta))))

  extern volatile uint32_t systick;
  extern uint32_t egg_state;

  #endif
#+end_src
